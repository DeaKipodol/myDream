# AI 고민상담 대화 분기/체크포인트/경로 전환 알고리즘 포트폴리오 설계서

문서는 AI 기반 고민상담 시스템의 대화 분기, 체크포인트, 경로 전환을 중심으로 한 전체 아키텍처와 구현 계획을 상세히 기록한다. 문서는 요약을 지양하고, 실제 구현을 목표로 한 구체적 설계를 단계별로 제시한다. 문서는 프론트엔드, 백엔드, 데이터베이스, AI 통합, 배포, 운영까지 포괄한다. 문서는 각 문장의 주어를 명확히 표기한다. 문서는 1인칭 단수 표현을 사용하지 않는다.

## 1. 비전과 목표

시스템은 사용자가 대화 도중 언제든지 다른 해결 경로로 전환하고, 특정 시점으로 복귀하며, 이미 쌓인 잘못된 논리를 신속히 교체할 수 있는 인터랙티브 상담 환경을 제공한다. 플랫폼은 대화 컨텍스트를 트리 기반 경로로 관리하고, 클릭 한 번으로 활성 경로를 재구성한다. 제품은 프론트엔드(HTML/CSS/JavaScript)와 백엔드(Python), NoSQL 데이터베이스, 컨테이너 기반 배포, CI/CD 파이프라인을 포함한다. 포트폴리오 산출물은 원리와 실제 동작이 일치하는 프로토타입 및 운영 가능한 서비스로 구성된다.

## 2. 문제 정의와 배경

대화형 AI는 종종 사용자 의도를 오해하거나, 이전의 잘못된 가정을 계속 누적하는 경향을 보인다. 시스템은 이 문제를 경로 전환과 체크포인트 회복으로 해결한다. 사용자 요구는 다음과 같이 정리된다. 시스템은 대화 분기점을 생성하고 기억해야 한다. 시스템은 기억된 시점으로 정확히 복귀해야 한다. 플랫폼은 A-B-C 경로에서 다른 가지의 노드 클릭 시 A-C 또는 A-B-F 같은 새로운 경로를 즉시 활성화해야 한다. 엔진은 기존 잘못된 논리 스택을 보존하되 활성 컨텍스트에서는 배제해야 한다. UI는 복잡한 복사-붙여넣기 없이 클릭만으로 경로 전환을 수행해야 한다.

### 파일 시스템과의 유사성

시스템의 핵심 개념은 파일 시스템의 디렉토리 구조와 매우 유사하다. 파일 시스템에서 폴더 내부의 파일들은 같은 경로를 가지고, 다른 폴더의 파일을 누르면 그 경로로 바뀌며 다시 같은 경로를 가지는 파일들로 폴더가 채워진다. 대화 시스템에서도 마찬가지로, 특정 대화 노드를 클릭하는 시점에 해당 대화의 맥락이 교체되는 것이 유일한 차이점이다.

파일 시스템에서는 물리적 파일과 폴더가 경로를 결정하지만, 대화 시스템에서는 논리적 대화 블록과 컨텍스트가 경로를 결정한다. 이 유사성은 시스템의 직관성을 크게 향상시킨다.

## 3. 용어 정의

- 분기점(Branch Point): 시스템이 대화 흐름에서 갈림을 기록하는 지점이다.
- 체크포인트(Checkpoint): 시스템이 복구 가능한 스냅샷을 남기는 저장 단위이다.
- 스냅샷(Snapshot): 시스템이 특정 시점의 경로, 메시지, 메타데이터를 불변 데이터로 저장한 상태이다.
- 활성 경로(Active Path): 시스템이 현재 표시하고 이어서 대화를 생성할 경로이다.
- 컨텍스트 블록(Context Block): 시스템이 AI가 응답을 생성할 때 참조하는 연속 메시지 묶음이다.
- LCA(최저 공통 조상, Lowest Common Ancestor): 시스템이 두 노드의 경로에서 가장 가까운 공통 조상 노드를 의미한다.
- 앵커 포인트(Anchor Point): 시스템이 병합 또는 전환의 기준이 되는 고정 시점을 의미한다.
- 단순 교체식(Path Rewrite): 시스템이 활성 경로를 재계산하여 교체하고, 비활성 경로를 보존 영역으로 이동하는 방식이다.

## 4. 사용자 경험(UX) 시나리오

시나리오 1: 사용자는 A→B→D 경로에서 상담을 진행한다. 사용자는 트리 뷰에서 C를 클릭한다. 시스템은 활성 경로를 A→C로 전환한다. 시스템은 기존 B→D 하위 대화를 보존 영역으로 이동한다. UI는 브레드크럼으로 A / C를 표시한다.

시나리오 2: 사용자는 동일한 A→B→D 상태에서 F를 클릭한다. 시스템은 LCA가 B임을 계산한다. 시스템은 활성 경로를 A→B→F로 재구성한다. UI는 경로 변경 전후의 차이를 하이라이트한다.

시나리오 3: 사용자는 A→B 상태에서 G를 클릭한다. 시스템은 LCA가 A임을 계산한다. 시스템은 활성 경로를 A→C→G로 재구성한다. UI는 형제 가지로의 점프임을 태그로 표시한다.

시나리오 4: 사용자는 B로 돌아가기 버튼을 누른다. 시스템은 앵커 포인트를 B로 설정하고 활성 경로를 A→B로 만든다. 시스템은 B 이후의 하위 대화를 병합 규칙에 따라 다룬다. 시스템은 동일 조상 하위의 병합 가능한 메시지를 병합하고 충돌하는 논리는 보존 영역으로 이동한다.

시나리오 5: 사용자는 잘못된 추론이 누적된 경로를 감지한다. 시스템은 경고 배지를 통해 “오류 논리 누적” 상태를 표시한다. 사용자는 체크포인트 목록에서 “정상 상태”로 명명된 시점을 클릭한다. 시스템은 해당 체크포인트 스냅샷으로 복원한다. AI는 복원된 컨텍스트만으로 새 답변을 생성한다.

잠만,, 중간점검: 시스템은 클릭 한 번으로 경로 전환을 약속한다. 설계는 LCA 기반 계산과 스냅샷 복원으로 이를 보장해야 한다. 병합 규칙은 사용자에게 예측 가능해야 한다. UI 메타 신호(브레드크럼, 배지, 하이라이트)는 혼란을 줄이는가를 다시 점검한다.

## 5. 개념 모델과 규칙

개념 모델은 루트가 있는 트리를 사용한다. 각 메시지 블록은 노드로 표현된다. 각 노드는 단 하나의 부모를 가진다. 활성 경로는 루트에서 현재 선택 노드까지의 노드 배열이다. 경로 전환은 LCA를 기준으로 재구성된다. 병합은 동일 조상 하위에서 사용자 승인 하에 제한적으로 수행된다.

경로 전환 규칙은 다음과 같이 정의된다.
1. 시스템은 대상 노드 T가 선택되면 현재 리프 노드 C와의 LCA L을 계산한다.
2. 시스템은 루트→L 경로를 접두부로 유지한다.
3. 시스템은 L→T 경로를 접미부로 덮어쓴다.
4. 시스템은 L 이후 기존 분기 경로를 보존 영역으로 이동한다.
5. 시스템은 전환 직전과 직후에 체크포인트를 생성한다.

병합 규칙은 다음과 같이 정의된다.
1. 시스템은 동일 조상 하위에서 의미적으로 등가인 메시지 묶음을 후보로 표기한다.
2. 시스템은 후보 묶음을 사용자가 승인하면 활성 경로로 병합한다.
3. 시스템은 충돌하는 내용은 보존 영역에 잔존시킨다.
4. 시스템은 병합 이후 새 체크포인트를 생성한다.

단순 교체식의 의미는 다음과 같이 정리된다. 시스템은 그래프 전체를 재배열하지 않는다. 시스템은 활성 경로만 재작성한다. 시스템은 비활성 분기를 삭제하지 않고 보존한다. 시스템은 병합을 별도의 승인 작업으로 분리한다.

잠만,, 중간점검: 규칙은 간결해야 유지보수가 가능하다. 전환 5단계와 병합 4단계는 구현 난이도, 사용자 인지 부하, 데이터 일관성에서 균형점을 제공하는가를 다시 검토한다.

## 6. 자료구조와 알고리즘

### 트리 구조의 적합성

시스템은 트리(Tree) 자료구조를 사용한다. 트리는 사이클이 없는 연결된 그래프(Acyclic Connected Graph)의 한 종류로, 대화가 B에서 A로 다시 돌아가는 순환 구조가 없기 때문에 가장 적합한 모델이다. 각 대화 블록은 노드(Node)로 표현되며, 파일 시스템의 디렉토리 구조와 동일한 원리를 따른다.

노드 구조는 다음 키를 포함한다. id, parentId, type(message|assistant|system), role(user|assistant|system), content, createdAt, meta(tags, score, source), childrenIds(옵션 캐시). 경로 구조는 노드 id 배열로 표현한다. 체크포인트 구조는 checkpointId, conversationId, activePathIds, timestamp, reason, snapshotHash를 포함한다.

LCA 계산은 두 가지 전략을 지원한다. 소규모 트리는 부모 포인터를 따라 올라가는 선형 방법을 사용한다. 대규모 트리는 깊이와 2^k 점프 테이블을 사용하는 Binary Lifting을 사용한다. 시스템은 노드 수 임계값으로 전략을 자동 선택한다.

### 핵심 알고리즘: 컨텍스트 교체 메커니즘

시스템의 핵심은 '현재 활성 대화 경로(Current Active Path)'를 관리하는 것이다. 사용자가 특정 노드를 클릭했을 때 대화 맥락을 바꾸는 과정은 다음과 같다:

1. **사용자 노드 클릭**: 사용자가 화면에 보이는 특정 대화 노드를 클릭한다.
2. **경로 탐색**: 클릭된 노드에서부터 시작해서 parent_id를 계속 따라가며 최상위 루트 노드까지의 전체 경로를 찾는다.
3. **활성 경로 교체**: 시스템이 기억하고 있던 '현재 활성 대화 경로'를 방금 찾은 경로로 완전히 교체한다.
4. **컨텍스트 생성 및 UI 업데이트**: 새로운 활성 경로에 포함된 노드들의 대화 내용을 순서대로 합쳐서 AI에게 전달할 새로운 컨텍스트를 만들고, 사용자 화면에는 해당 노드들만 하이라이트하여 현재 대화의 흐름을 시각적으로 보여준다.
5. **대화 재개**: 사용자가 이어서 입력을 하면, AI는 방금 생성된 컨텍스트를 기반으로 답변을 생성하고, 새로운 대화 노드는 클릭된 노드의 자식으로 추가된다.

이 로직은 어떤 노드를 클릭하든 동일하게 적용되며, 항상 루트에서부터 클릭한 노드까지의 유일한 경로를 찾아 컨텍스트로 삼기 때문에 매우 안정적이다.

경로 계산:
1. 시스템은 현재 리프 C와 목표 T를 입력으로 받는다.
2. 시스템은 L = LCA(C, T)를 계산한다.
3. 시스템은 prefix = path(root, L)를 구성한다.
4. 시스템은 suffix = path(L, T)를 구성하되 L을 중복 배제한다.
5. 시스템은 activePath = prefix + suffix로 재구성한다.

체크포인트 생성:
1. 시스템은 전환 전 activePath를 스냅샷으로 저장한다.
2. 시스템은 전환 후 새 activePath를 스냅샷으로 저장한다.
3. 시스템은 스냅샷 해시를 계산하여 무결성을 기록한다.

보존 영역 이동:
1. 시스템은 L 이후 분기들을 shelves 컬렉션으로 이동 마킹한다(실제 데이터 이동 없이 레이블 기반 가시성 제어를 권장한다).
2. 시스템은 UI에 보존 스레드를 표시하되 기본 뷰에서는 비활성화한다.

시간/공간 복잡도:
- 선형 LCA는 O(h) 시간이 소요된다. Binary Lifting은 O(log N) 시간이 소요된다. 경로 재구성은 O(length(prefix)+length(suffix))가 소요된다. 스냅샷 저장은 경로 길이에 선형이다.

엣지 케이스는 다음과 같이 처리한다.
- 시스템은 루트 또는 동일 노드 클릭 시 no-op으로 처리한다.
- 시스템은 부모가 없는 노드와 순환 참조를 검증 단계에서 차단한다.
- 시스템은 삭제된 노드 참조 발생 시 가장 가까운 유효 조상으로 강등한다.
- 시스템은 동시 전환 경쟁 상태를 버전 키로 직렬화한다.

잠만,, 중간점검: 알고리즘은 가독성이 높아야 디버깅이 수월하다. 선형 방법과 Binary Lifting의 전환 기준은 실제 데이터 밀도와 깊이에 따라 조정돼야 한다.

## 7. 체크포인트/스냅샷 전략

시스템은 다음 시점에 체크포인트를 생성한다. 대화 턴 쌍 완료 시점, 분기 생성 직후, 경로 전환 직전과 직후, 병합 승인 직후, 중요한 설정 변경 직후. 시스템은 스냅샷을 불변으로 저장한다. 시스템은 동일 스냅샷 중복을 해시로 제거한다. 시스템은 보존 정책으로 최근 N개 전부 보관, 그 이전은 일별 대표 스냅샷만 유지하는 하이브리드 전략을 적용한다. 시스템은 복원 시 스냅샷의 activePath와 해당 메시지 컨텐츠만을 로드한다. 시스템은 복원 이후의 새 분기는 새로운 타임라인으로 기록한다.

## 8. 데이터 모델(NoSQL)

데이터베이스는 문서 지향 저장소를 사용한다. 권장 구현은 MongoDB 또는 DynamoDB이다. 주요 컬렉션/테이블은 다음과 같다.

- conversations: { _id, ownerId, title, createdAt, updatedAt, rootId }
- nodes: { _id, conversationId, parentId, role, type, content, meta, createdAt, depth }
- checkpoints: { _id, conversationId, activePathIds, reason, createdAt, snapshotHash }
- shelves: { _id, conversationId, fromCheckpointId, hiddenPathIds, createdAt, note }
- sessions: { _id, conversationId, activeCheckpointId, uiState, createdAt, updatedAt }
- users: { _id, email, hashedPassword, roles, createdAt }

인덱스 설계는 다음과 같다. nodes(conversationId, parentId, depth), checkpoints(conversationId, createdAt), sessions(conversationId), shelves(conversationId). 시간 기반 정렬과 범위 질의는 createdAt 복합 인덱스로 지원한다. 문서 크기 제약은 메시지 본문을 별도 blob 스토리지로 분리하여 해결한다.

참조 일관성은 다음 방식으로 유지된다. 시스템은 parentId 존재 검사를 트랜잭션 또는 멱등 보정 작업으로 수행한다. 시스템은 소프트 삭제 플래그로 이력 보존을 지원한다. 시스템은 이벤트 소싱을 고려하여 전환, 병합, 복원 이벤트 로그를 남긴다.

## 9. API 설계

백엔드 API는 REST 우선으로 시작하고, 실시간 갱신을 위해 WebSocket/Server-Sent Events를 보완한다. 핵심 엔드포인트는 다음과 같다.

- POST /conversations: 대화 생성
- GET /conversations/{id}: 대화 조회
- POST /conversations/{id}/nodes: 노드 생성
- GET /conversations/{id}/nodes/{nodeId}/path: 루트→노드 경로 조회
- POST /conversations/{id}/switch: { targetNodeId }로 경로 전환 수행
- POST /conversations/{id}/checkpoints: 체크포인트 생성
- GET /conversations/{id}/checkpoints: 체크포인트 목록 조회
- POST /conversations/{id}/restore: { checkpointId }로 복원
- GET /conversations/{id}/shelves: 보존 스레드 목록
- POST /ai/generate: AI 응답 생성(컨텍스트 블록 포함)

오류 모드는 다음과 같다. 시스템은 400으로 잘못된 노드 참조를 반환한다. 시스템은 409로 동시 전환 충돌을 보고한다. 시스템은 422로 병합 불가 상태를 통지한다. 시스템은 500으로 내부 오류를 보고하되 이벤트 로그를 남긴다.

## 10. 프론트엔드 설계(HTML/CSS/JS)

프론트엔드는 다음 구성 요소로 이루어진다. 트리 패널(TreeView), 대화 패널(ChatView), 브레드크럼(Breadcrumbs), 체크포인트 패널(CheckpointList), 보존 스레드 패널(ShelvesView), 상태 배지(StatusBadges). 상태 관리 계층은 activePath, selectedNode, checkpoints, shelves, uiFlags를 보유한다.

상호작용 흐름은 다음과 같다. 사용자는 TreeView에서 노드를 클릭한다. 프론트엔드는 현재 리프와 대상 노드로 전환 요청을 전송한다. 백엔드는 LCA 기반 경로를 계산한다. 프론트엔드는 응답된 경로로 ChatView와 Breadcrumbs를 재렌더링한다. 프론트엔드는 변화된 구간을 하이라이트한다.

접근성은 다음 원칙을 따른다. 키보드 탐색은 방향키로 형제 이동, 화살표 좌/우로 부모/자식 이동을 지원한다. 스크린리더를 위해 노드의 깊이와 위치를 aria-label로 제공한다. 색각 보정 팔레트를 제공한다.

성능 최적화는 다음 전략을 사용한다. 가상 스크롤을 통한 긴 스레드 렌더링, 경로 구간에 대한 메모이제이션, layout thrashing 방지, 폰트 서브셋팅, 코드 스플리팅. 에러 바운더리는 전환 실패와 복원 실패를 명시적으로 분기 처리한다.

잠만,, 중간점검: UI는 “클릭 한 번” 목표를 달성해야 한다. 브레드크럼, 배지, 하이라이트, 패널 레이아웃이 사용자 인지 부하를 낮추는지 다시 확인한다.

## 11. 백엔드 설계(Python)

백엔드는 FastAPI를 사용한다. 애플리케이션 계층은 라우터, 서비스, 리포지토리, 모델로 분리된다. 경로 전환 서비스는 LCA 서비스, 스냅샷 서비스, 보존 스레드 서비스에 의존한다. 데이터 계층은 비동기 드라이버를 사용하여 동시성을 확보한다.

트랜잭션 흐름은 다음과 같다. 서비스는 전환 요청을 수신한다. 서비스는 버전 키를 검증한다. 서비스는 LCA를 계산한다. 서비스는 전/후 체크포인트를 기록한다. 서비스는 병합 또는 보존 이동을 수행한다. 서비스는 최종 activePath를 기록하고 세션을 갱신한다.

확장성과 안정성은 다음으로 확보한다. 서비스는 캐시 레이어(Redis)를 사용하여 경로 계산과 경로 조회를 가속한다. 서비스는 지수 백오프로 AI 호출을 안정화한다. 서비스는 Circuit Breaker로 외부 오류 전파를 차단한다.

## 12. AI 통합

AI 모듈은 프로바이더 추상화 레이어를 갖는다. 모듈은 시스템 프롬프트, 사용자 프롬프트, 활성 경로 컨텍스트 블록을 조합하여 요청을 생성한다. 모듈은 토큰 한도를 초과하지 않도록 컨텍스트 블록을 요약하지 않고 선택적으로 슬라이싱한다. 모듈은 잘못된 논리 누적이 감지되면 경고 신호를 UI에 전달한다. 모듈은 경로 전환 후 이전 경로의 결론을 재사용하지 않는다.

프롬프트 전략은 다음과 같다. 모듈은 문제 재서술, 가정 명시, 단계별 추론, 반례 탐색 지시를 포함한다. 모듈은 도메인 태그(예: 불안, 진로, 대인)를 메타로 전달받아 어투와 구조를 조정한다. 모듈은 안전 가드로 민감 주제 대응 정책을 적용한다.

## 13. 컨테이너와 배포

컨테이너화는 프론트엔드 정적 빌드와 백엔드 API, 프록시(Nginx)로 구성된다. 백엔드는 멀티스테이지 Dockerfile로 빌드한다. 의존성은 잠금 파일로 고정한다. Compose 또는 Helm 차트로 로컬/스테이징/프로덕션 환경을 구성한다. 프록시는 TLS 종료와 정적 캐시, 압축을 담당한다. 헬스체크 엔드포인트는 /healthz, /readyz로 제공된다.

배포 전략은 다음과 같다. 스테이징에서 블루/그린을 이용한 점진 배포를 수행한다. 롤백은 이전 이미지 태그로 즉시 복구한다. 환경 변수는 시크릿 매니저로 관리한다. 로그는 표준 출력으로 집계하고 중앙 수집기로 전송한다.

## 14. CI/CD 파이프라인

CI는 lint, type check, unit test, integration test, 빌드를 실행한다. CI는 실패 시 병합을 차단한다. CD는 도커 이미지를 레지스트리에 푸시하고 스테이징으로 자동 배포한다. E2E 테스트가 성공하면 프로덕션 배포를 승인한다. 서드파티 의존성 보안 스캔을 정기적으로 수행한다.

## 15. 보안과 개인정보 보호, 성능

보안은 인증(JWT), 권한(RBAC), 속도 제한(rate limiting), CORS 정책, 입력 검증, 감사 로그로 구성된다. 개인정보는 최소 수집 원칙을 따른다. 민감 데이터는 암호화 저장을 기본으로 한다. 성능은 캐시, 인덱스 최적화, 비동기 처리, 큐 기반 비동기 작업으로 확보한다. 대화 데이터는 데이터 마스킹을 적용하여 2차 처리에서 식별을 방지한다.

## 16. 테스트 전략

단위 테스트는 LCA 계산, 경로 재구성, 체크포인트 생성/복원, 병합 결정 함수를 대상으로 한다. 속성 기반 테스트는 경로 전환 불변식(루트 접두부 보존, 중복 제거)을 검증한다. 통합 테스트는 API 흐름 전반을 검증한다. E2E 테스트는 브라우저 자동화를 통해 노드 클릭→경로 전환→AI 응답 표시까지 검증한다. 부하 테스트는 경로 깊이와 동시 사용자 수를 변수로 시나리오를 구성한다.

## 17. 운영과 관측(Observability)

관측성은 구조화 로그, 메트릭, 트레이싱으로 구성된다. 핵심 메트릭은 전환 지연, 복원 성공률, 병합 승인률, AI 응답 지연, 에러 비율이다. SLO는 전환 지연 200ms p95, 복원 성공률 99.5%를 목표로 한다. 알람은 임계치 초과 시 페이지를 발송한다. 대시보드는 경로 전환 분포와 실패 원인 상위 항목을 시각화한다.

## 18. 로드맵

1단계는 경로 전환 MVP와 체크포인트 저장/복원을 제공한다. 2단계는 병합 승인 UX와 보존 스레드 가시화, AI 프롬프트 통합을 제공한다. 3단계는 확장 모드(Binary Lifting), 캐시, 관측성, 보안 강화를 제공한다. 4단계는 다국어 지원과 모바일 최적화를 제공한다.

## 19. 성공 기준

성공 기준은 다음과 같다. 사용자는 복사-붙여넣기 없이 클릭만으로 경로 전환을 수행한다. 사용자는 2회 이상의 잘못된 논리 누적 상황에서 체크포인트 복원으로 정상 흐름을 회복한다. 시스템은 분당 전환 100회에서 p95 지연 200ms 이하를 유지한다. 운영자는 이벤트 로그로 장애 원인을 30분 내에 파악한다.

## 20. 구현 세부(샘플 구조와 의사코드)

프론트엔드 상태 구조 예시는 아래와 같다.

state = {
    activePathIds: ["A","B","D"],
    selectedNodeId: "D",
    checkpoints: [...],
    shelves: [...],
    uiFlags: { merging: false, warning: false }
}

핸들러 의사코드는 아래와 같다.

onNodeClick(targetId) {
    // 시스템은 백엔드에 전환 요청을 보낸다
    // 시스템은 응답 activePath로 상태를 교체한다
}

백엔드 전환 로직 의사코드는 아래와 같다.

switchPath(conversationId, currentLeafId, targetId) {
    // 시스템은 L = LCA(currentLeafId, targetId)를 계산한다
    // 시스템은 prefix와 suffix를 계산한다
    // 시스템은 전/후 체크포인트를 기록한다
    // 시스템은 보존 스레드로 이전 분기를 표시한다
    // 시스템은 activePath를 저장하고 반환한다
}

## 21. 에러 모드와 복구 전략

전환 충돌은 버전 불일치로 식별된다. 시스템은 재시도 토큰과 함께 409를 반환한다. 복원 실패는 스냅샷 누락 또는 무결성 실패로 발생한다. 시스템은 가장 가까운 이전 스냅샷으로의 자동 롤백 옵션을 제공한다. AI 호출 실패는 지수 백오프와 대체 제공자 장애 조치로 보완한다. UI는 명확한 상태 배지와 재시도 버튼을 제공한다.

## 22. 데이터 일관성, 마이그레이션, 백업

일관성은 세션 버전 키와 멱등 요청 식별자로 보장된다. 마이그레이션은 컬렉션 간 스키마 진화에 대비한 읽기-쓰기 호환 전략을 적용한다. 백업은 스냅샷 기반 증분과 일일 전체 백업을 병행한다. 복구 연습은 분기별로 수행한다.

## 23. 접근성, 국제화, 윤리

접근성은 WCAG 가이드라인을 준수한다. 국제화는 리소스 번들을 사용하여 레이블과 시스템 메시지를 분리한다. 윤리 가이드는 민감 주제에 대한 대응, 오남용 방지, 설명 가능성 메타 태그를 포함한다.

## 24. 개발자 경험(DX)

개발 환경은 hot reload, 파일 워치, 미니 시드 데이터, 계약 기반 테스트로 생산성을 높인다. API 스펙은 OpenAPI로 관리한다. 디자인 시스템은 토큰 기반으로 테마를 구성한다. 모듈 경계는 명확히 유지한다.

중간점검: DX는 빠른 실험과 안전한 롤백을 동시에 지원해야 한다. 체크포인트와 이벤트 로그는 개발자 디버깅에도 직접적인 가치를 제공해야 한다.

## 25. 데모 플로우(포트폴리오 관점)

데모는 다음 순서로 진행된다. 사용자는 샘플 대화를 로드한다. 사용자는 트리에서 형제 노드를 클릭하여 경로를 전환한다. 시스템은 브레드크럼과 대화 패널을 즉시 갱신한다. 사용자는 체크포인트 패널에서 이전 시점으로 복원한다. 시스템은 복원 후 AI 응답을 새 컨텍스트로 생성한다. 운영자는 보존 스레드 패널에서 과거 분기를 검토한다. 관람자는 LCA 계산 로그와 이벤트 타임라인을 확인한다.

## 26. 요약을 대신하는 결론적 기록

문서는 요약 대신 결론적 기록을 제공한다. 시스템은 트리 경로를 기반으로 클릭 한 번의 경로 전환과 스냅샷 복원을 제공한다. 알고리즘은 LCA와 경로 재작성으로 단순하고 예측 가능한 동작을 보장한다. 데이터 모델은 문서 지향 저장소로 경량성과 확장성을 동시에 확보한다. 프론트엔드와 백엔드는 명확한 계약으로 결합되고, 컨테이너와 CI/CD는 반복 가능한 배포를 보장한다. 보안, 테스트, 관측성은 제품 품질의 하한을 설정한다. 로드맵은 MVP에서 확장 모드까지 점진적 성숙을 안내한다. 포트폴리오 산출물은 동작하는 데모와 설계 문서로 완결된다.

# AI 고민상담 트리 구조 대화 시스템 개발 포트폴리오

## 프로젝트 개요

본 프로젝트는 사용자가 AI와의 대화 중 다양한 해결책을 탐색할 수 있도록 트리 구조의 대화 분기 시스템을 구현하는 것을 목표로 합니다. 기존의 일방향적 대화 흐름을 벗어나, 사용자가 언제든지 이전 분기점으로 돌아가거나 다른 해결책을 선택할 수 있는 유연한 대화 환경을 제공합니다.

## 핵심 아이디어 및 문제 인식

### 현재 대화 시스템의 한계점

현재 대부분의 AI 대화 시스템은 일방향적인 대화 흐름을 가지고 있습니다. 사용자가 AI와 대화를 진행하다가 특정 시점에서 AI가 잘못된 방향으로 이해하거나 부적절한 해결책을 제시할 경우, 사용자는 다음과 같은 어려움을 겪습니다:

1. **맥락 손실**: 이미 진행된 대화의 맥락을 잃어버린 상태에서 새로운 접근이 필요
2. **비효율적인 재시작**: 마우스 드래그로 이전 대화를 복사하여 새로운 창에 붙여넣는 번거로운 과정
3. **잘못된 시도의 누적**: 이전의 잘못된 시도들이 계속해서 AI의 응답에 영향을 미치는 문제

### 트리 구조 대화 시스템의 혁신적 접근

이러한 문제점들을 해결하기 위해 제안하는 시스템은 다음과 같은 특징을 가집니다:

**분기점 기반 대화 관리**: 각 대화 단계에서 여러 해결책이 제시될 때, 이를 분기점으로 저장하고 관리합니다. 사용자는 언제든지 원하는 분기점으로 돌아가거나 다른 해결책을 선택할 수 있습니다.

**컨텍스트 보존**: 분기점으로 이동할 때 이전의 대화 맥락을 유지하면서 새로운 방향으로 대화를 진행할 수 있습니다.

**자유로운 탐색**: 사용자는 대화의 흐름에 구애받지 않고 자유롭게 다양한 해결책을 탐색할 수 있습니다.

## 시스템 아키텍처 설계

### 데이터 구조 설계

시스템의 핵심은 트리 구조를 활용한 대화 관리입니다. 각 대화 블록은 노드로 표현되며, 다음과 같은 구조를 가집니다:

```
루트 노드 (A)
├── 자식 노드 1 (B)
│   ├── 자식 노드 1-1 (D)
│   ├── 자식 노드 1-2 (E)
│   └── 자식 노드 1-3 (F)
└── 자식 노드 2 (C)
    ├── 자식 노드 2-1 (G)
    ├── 자식 노드 2-2 (H)
    └── 자식 노드 2-3 (I)
```

### 경로 관리 알고리즘

사용자가 특정 노드를 클릭했을 때, 시스템은 다음과 같은 과정을 거쳐 새로운 대화 맥락을 구성합니다:

1. **경로 계산**: 클릭된 노드에서 루트까지의 경로를 계산합니다.
2. **컨텍스트 재구성**: 해당 경로상의 모든 노드들의 대화 내용을 결합하여 새로운 컨텍스트를 생성합니다.
3. **분기점 업데이트**: 현재 활성화된 분기점을 새로운 경로에 맞게 업데이트합니다.

### 구체적인 동작 예시

사용자가 현재 A → B → D 경로에 있다고 가정합니다:

- **C 노드 클릭**: A → C 경로로 변경되어 C와 관련된 대화 맥락으로 전환
- **F 노드 클릭**: A → B → F 경로로 변경되어 F와 관련된 대화 맥락으로 전환
- **G 노드 클릭**: A → C → G 경로로 변경되어 G와 관련된 대화 맥락으로 전환

이러한 방식으로 사용자는 언제든지 원하는 분기점으로 이동하여 다른 해결책을 탐색할 수 있습니다.

## 기술적 구현 계획

### 프론트엔드 구현

**HTML/CSS/JavaScript 기반 프로토타입**: 먼저 핵심 알고리즘을 이해하고 검증하기 위해 웹 기반 프로토타입을 개발합니다. 이를 통해 사용자 인터페이스와 상호작용 방식을 구체화할 수 있습니다.

**트리 구조 시각화**: 사용자가 현재 위치와 가능한 분기점들을 직관적으로 파악할 수 있도록 트리 구조를 시각적으로 표현합니다.

**분기점 네비게이션**: 각 분기점을 클릭 가능한 요소로 구현하여 사용자가 쉽게 탐색할 수 있도록 합니다.

### 백엔드 아키텍처

**서버 언어**: Python을 사용하여 RESTful API를 구현합니다. Python의 풍부한 라이브러리와 AI 모델 통합의 용이성을 고려한 선택입니다.

**데이터베이스**: NoSQL 기반 데이터베이스를 사용하여 트리 구조의 대화 데이터를 효율적으로 저장하고 관리합니다. 각 대화 노드와 분기점 정보를 유연하게 저장할 수 있습니다.

**컨테이너화**: Docker를 활용하여 개발 환경과 배포 환경의 일관성을 보장합니다.

**CI/CD 파이프라인**: 자동화된 배포 시스템을 구축하여 개발 효율성을 높입니다.

### AI 통합 전략

**챗봇 엔진 통합**: 트리 구조 대화 시스템에 AI 챗봇을 통합하여 실제 대화 기능을 구현합니다.

**컨텍스트 관리**: AI가 각 분기점에서의 대화 맥락을 정확히 이해하고 적절한 응답을 생성할 수 있도록 컨텍스트 관리 시스템을 구축합니다.

**주제별 분기**: 사용자의 고민이나 질문의 주제에 따라 자동으로 분기를 생성하고 관리하는 시스템을 개발합니다.

## 사용자 경험 설계

### 직관적인 네비게이션

사용자는 복잡한 기술적 세부사항을 이해하지 않고도 시스템을 사용할 수 있어야 합니다. 이를 위해 다음과 같은 UX 원칙을 적용합니다:

**시각적 피드백**: 현재 위치와 가능한 분기점들을 명확하게 표시합니다.

**원클릭 이동**: 복잡한 조작 없이 클릭 한 번으로 원하는 분기점으로 이동할 수 있습니다.

**맥락 보존**: 분기점 이동 시에도 이전 대화의 맥락이 유지되어 자연스러운 대화 흐름을 보장합니다.

### 대화의 자유도와 구조의 균형

시스템은 대화의 자유도를 보장하면서도 구조적 무결성을 유지해야 합니다:

**자유로운 분기**: 사용자는 언제든지 새로운 분기를 생성하거나 기존 분기로 이동할 수 있습니다.

**구조적 제약**: 무분별한 분기 생성을 방지하고 논리적인 대화 흐름을 유지합니다.

**상위 노드 관계**: 각 분기는 상위 노드와의 관계를 유지하여 전체적인 대화의 일관성을 보장합니다.

## 개발 단계별 계획

### 1단계: 핵심 알고리즘 구현

먼저 트리 구조 대화 관리의 핵심 알고리즘을 HTML/CSS/JavaScript로 구현합니다. 이 단계에서는 다음 사항들을 중점적으로 개발합니다:

- 트리 구조 데이터 모델 설계
- 경로 계산 및 컨텍스트 재구성 알고리즘
- 분기점 생성 및 관리 시스템
- 사용자 인터페이스 프로토타입

### 2단계: 백엔드 시스템 구축

프론트엔드 프로토타입이 완성된 후, 실제 서비스 운영을 위한 백엔드 시스템을 구축합니다:

- Python 기반 RESTful API 개발
- NoSQL 데이터베이스 설계 및 구현
- Docker 컨테이너화
- CI/CD 파이프라인 구축

### 3단계: AI 통합 및 고도화

백엔드 시스템이 안정화된 후, AI 챗봇을 통합하여 실제 대화 기능을 구현합니다:

- AI 모델 통합 및 최적화
- 컨텍스트 관리 시스템 고도화
- 주제별 자동 분기 생성 기능
- 사용자 피드백 기반 시스템 개선

## 기술적 도전과제 및 해결 방안

### 컨텍스트 관리의 복잡성

트리 구조에서 각 분기점의 컨텍스트를 정확히 관리하는 것은 기술적으로 복잡한 문제입니다. 이를 해결하기 위해 다음과 같은 접근 방식을 사용합니다:

**체크포인트 시스템**: 각 분기점을 체크포인트로 저장하여 정확한 시점으로 복귀할 수 있도록 합니다.

**컨텍스트 병합 알고리즘**: 상위 노드들의 정보를 효과적으로 결합하여 새로운 컨텍스트를 생성합니다.

**메모리 최적화**: 불필요한 대화 데이터를 효율적으로 관리하여 시스템 성능을 최적화합니다.

### 사용자 인터페이스의 직관성

복잡한 트리 구조를 사용자가 쉽게 이해하고 조작할 수 있도록 하는 것이 중요한 과제입니다:

**시각적 표현**: 트리 구조를 직관적인 그래픽으로 표현하여 사용자가 현재 위치와 가능한 경로를 쉽게 파악할 수 있도록 합니다.

**인터랙션 디자인**: 복잡한 조작을 단순한 클릭이나 터치로 대체하여 사용성을 향상시킵니다.

**피드백 시스템**: 사용자의 행동에 대한 즉각적이고 명확한 피드백을 제공합니다.

## 예상 효과 및 활용 분야

### 사용자 경험 개선

이 시스템을 통해 사용자는 다음과 같은 개선된 경험을 얻을 수 있습니다:

**효율적인 탐색**: 다양한 해결책을 빠르고 쉽게 탐색할 수 있습니다.

**맥락 보존**: 대화의 맥락을 잃지 않고 다양한 방향으로 대화를 진행할 수 있습니다.

**자유로운 실험**: 다양한 접근 방식을 자유롭게 시도해볼 수 있습니다.

### 활용 가능한 분야

이 시스템은 다음과 같은 다양한 분야에서 활용될 수 있습니다:

**AI 고민상담**: 사용자의 고민에 대해 다양한 관점에서 접근할 수 있는 상담 시스템

**교육 플랫폼**: 학습자가 다양한 학습 경로를 탐색할 수 있는 교육 시스템

**의사결정 지원**: 복잡한 의사결정 상황에서 다양한 옵션을 체계적으로 탐색할 수 있는 시스템

**창작 도구**: 다양한 아이디어와 접근 방식을 탐색할 수 있는 창작 지원 도구

## 결론 및 향후 계획

본 프로젝트는 기존의 일방향적 대화 시스템의 한계를 극복하고, 사용자가 자유롭게 다양한 해결책을 탐색할 수 있는 혁신적인 시스템을 구현하는 것을 목표로 합니다. 트리 구조를 활용한 대화 분기 시스템은 AI와의 상호작용 방식을 근본적으로 변화시킬 수 있는 잠재력을 가지고 있습니다.

앞으로의 개발 과정에서 사용자 피드백을 지속적으로 수집하고 시스템을 개선해나가며, 최종적으로는 실제 서비스로 출시하여 많은 사용자들이 혜택을 누릴 수 있도록 할 계획입니다. 또한 이 시스템의 핵심 기술을 오픈소스로 공개하여 더 많은 개발자들이 참여하고 발전시킬 수 있도록 하는 것도 고려하고 있습니다.

이 프로젝트를 통해 AI와의 대화가 단순한 질문과 답변을 넘어서, 사용자가 자신의 문제를 다각도로 탐색하고 해결할 수 있는 진정한 상호작용 도구로 발전할 수 있기를 기대합니다.

# 27. 상세 API 계약과 예시 페이로드

시스템은 API 계약을 문장형으로 명시한다. 시스템은 각 엔드포인트의 입력, 출력, 에러를 분리한다.

경로 전환 API 계약은 다음과 같다. 시스템은 입력으로 conversationId, currentLeafId, targetNodeId, clientVersion을 받는다. 시스템은 출력으로 activePathIds, lcaNodeId, checkpointBeforeId, checkpointAfterId, shelvesDelta를 반환한다. 시스템은 에러로 400(유효하지 않은 노드), 404(대화 없음), 409(버전 충돌), 500(내부 오류)을 정의한다.

체크포인트 복원 API 계약은 다음과 같다. 시스템은 입력으로 conversationId, checkpointId를 받는다. 시스템은 출력으로 activePathIds와 restoredAt을 반환한다. 시스템은 보존 스레드 영향도를 shelvesDelta로 보고한다.

AI 응답 생성 API 계약은 다음과 같다. 시스템은 입력으로 promptParts, contextBlockIds, maxTokens, domainTags를 받는다. 시스템은 출력으로 messageId, content, usageMeta를 반환한다. 시스템은 토큰 한도 초과 시 422를 반환한다.

# 28. LCA 실무 구현 전략

시스템은 소규모 트리에 대해 부모 포인터 집합과 깊이 정규화를 사용한다. 시스템은 두 노드의 깊이를 맞춘 다음 동시에 부모를 상승시켜 LCA를 찾는다. 시스템은 이 방법으로 O(h) 시간을 보장한다.

시스템은 대규모 트리에 대해 Binary Lifting을 사용한다. 시스템은 각 노드에 대해 2^k 부모 표를 미리 계산한다. 시스템은 쿼리 시 두 노드의 깊이를 맞춘 뒤, 상위 비트부터 점프하여 공통 조상 직전까지 이동한다. 시스템은 마지막으로 한 단계 올려 LCA를 결정한다.

시스템은 대안으로 Euler Tour + RMQ 방식을 고려한다. 시스템은 노드 방문 순서와 깊이를 배열로 기록하고, 시스템은 Sparse Table로 최소 깊이 질의를 처리한다. 시스템은 이 방식으로 O(1) 질의와 O(N log N) 전처리를 달성한다.

시스템은 프로젝트 초기에는 선형 방식으로 시작하고, 시스템은 노드 수 임계값을 초과하면 자동으로 Binary Lifting을 활성화한다. 시스템은 전환 기준을 구성 파일로 노출한다.

# 29. UX 마이크로인터랙션과 가시성 규칙

프론트엔드는 노드 클릭 시 150ms 이내에 시각적 피드백을 표시한다. 프론트엔드는 하이라이트 컬러와 페이드 애니메이션으로 경로 교체 구간을 강조한다. 프론트엔드는 스크롤 위치를 LCA 지점으로 부드럽게 이동한다.

프론트엔드는 브레드크럼에서 접두부 구간을 고정 스타일로, 접미부 구간을 강조 스타일로 구분한다. 프론트엔드는 보존 스레드를 사이드 패널의 회색 카드로 배치한다. 프론트엔드는 키보드 사용자를 위해 Enter 키로 클릭과 동일 동작을 제공한다.

프론트엔드는 실패 시 즉시 배지와 토스트를 표시한다. 프론트엔드는 409 충돌 시 “다시 시도”와 “새로고침” 선택지를 제공한다. 프론트엔드는 복원 시 변경된 메시지 수를 요약 배지로 표기한다.

잠만,, 중간점검: 마이크로인터랙션은 가시성 향상에 실효가 있는가를 점검한다. 색 대비, 애니메이션 시간, 스크롤 이동 거리는 실제 사용성에 영향을 준다.

# 30. 비정상 시나리오와 회귀 테스트 카탈로그

시스템은 잘못된 부모 참조를 입력으로 받는 시나리오를 정의한다. 시스템은 이 시나리오에서 400을 반환하고 지원 문구를 포함한다. 시스템은 순환 참조 삽입 시도를 차단하고 400을 반환한다.

시스템은 동시 전환 경합 시나리오를 정의한다. 시스템은 두 클라이언트가 동시에 전환을 요청하면 한 요청을 409로 거절한다. 시스템은 실패 요청에 재시도 토큰을 부여한다.

시스템은 스냅샷 무결성 오류 시나리오를 정의한다. 시스템은 스냅샷 해시가 불일치하면 복원을 거부한다. 시스템은 가장 가까운 이전 스냅샷으로 자동 복구 옵션을 제시한다.

시스템은 회귀 테스트 카탈로그를 유지한다. 시스템은 각 버그에 대해 최소 1개의 재현 테스트를 추가한다. 시스템은 전환 불변식, 병합 불변식, 복원 불변식을 테스트로 보장한다.

# 31. 성능 예산과 부하 모델

시스템은 전환 API p95 200ms, p99 400ms를 성능 예산으로 설정한다. 시스템은 복원 API p95 300ms를 목표로 한다. 시스템은 AI 응답 대기시간 p95 2.5s를 목표로 한다.

시스템은 부하 모델을 분당 전환 100회, 동시 사용자 1,000명, 평균 경로 길이 12로 가정한다. 시스템은 캐시 적중률 80%를 목표로 한다. 시스템은 캐시 미스 시 성능 저하 완충을 위해 읽기 복제를 사용한다.

# 32. 보안 위협 모델링(STRIDE)

시스템은 위장(Spoofing)에 대해 JWT 서명 검증과 토큰 바인딩을 적용한다. 시스템은 변조(Tampering)에 대해 전환 이벤트와 스냅샷에 해시를 부여한다. 시스템은 부인(Repudiation)에 대해 감사 로그와 요청 서명을 기록한다.

시스템은 정보 유출(Information Disclosure)에 대해 필드 레벨 마스킹과 전송 구간 암호화를 적용한다. 시스템은 서비스 거부(Denial of Service)에 대해 속도 제한과 IP 차단을 적용한다. 시스템은 권한 상승(Elevation of Privilege)에 대해 역할 기반 접근 제어를 적용한다.

# 33. 데이터 보존 정책과 규정 준수

시스템은 기본 보존 기간을 180일로 설정한다. 시스템은 사용자가 보존 설정을 대화 단위로 조정할 수 있도록 허용한다. 시스템은 삭제 요청에 대해 지연 삭제와 즉시 비가역 삭제 옵션을 제공한다.

시스템은 규정 준수를 위해 접근 로그와 변경 이력을 최소 1년 보관한다. 시스템은 민감 데이터에 대해 키 관리 시스템을 사용한다. 시스템은 데이터 전송 지역 정책을 명시한다.

# 34. 배포 파이프라인 단계별 정의

시스템은 파이프라인을 소스 검사, 빌드, 테스트, 보안 스캔, 이미지 서명, 스테이징 배포, E2E, 프로덕션 배포 단계로 분리한다. 시스템은 각 단계의 성공 조건을 명시한다.

시스템은 커밋 푸시 시 CI가 자동 시작되도록 설정한다. 시스템은 태그 푸시 시 릴리스 빌드를 생성한다. 시스템은 릴리스 노트에 API 변경과 마이그레이션 지침을 포함한다.

# 35. 위험 등록부와 완화 전략

시스템은 성능 열화 위험을 등록한다. 시스템은 캐시 전략과 지표 모니터링으로 완화한다. 시스템은 데이터 무결성 위험을 등록한다. 시스템은 스냅샷 해시와 주기적 검증으로 완화한다.

시스템은 공급자 종속 위험을 등록한다. 시스템은 AI 프로바이더 추상화로 완화한다. 시스템은 운영 과부하 위험을 등록한다. 시스템은 자동화와 관측성을 강화하여 완화한다.

# 36. 비기능 요구사항 상세

시스템은 가용성 99.9%를 목표로 한다. 시스템은 평균 복구 시간 30분을 목표로 한다. 시스템은 변경 실패율 15% 이하를 목표로 한다. 시스템은 보안 취약점 패치 리드타임 7일을 목표로 한다.

시스템은 접근성을 AA 레벨로 준수한다. 시스템은 국제화를 영어와 한국어로 제공한다. 시스템은 모바일과 데스크톱에서 동일 기능을 보장한다.

# 37. 예제 시나리오 확장(A/B/C/F/G)

### 파일 시스템 유사성 기반 시나리오

시스템은 사용자가 A→B→D 상태에서 F를 클릭하는 경우를 처리한다. 파일 시스템에서 다른 폴더의 파일을 클릭하는 것과 동일하게, 시스템은 LCA를 B로 계산하고 A→B→F를 활성화한다. 시스템은 B→D 하위 스레드를 보존 영역으로 표시한다.

시스템은 사용자가 동일 상태에서 C를 클릭하는 경우를 처리한다. 파일 시스템에서 상위 디렉토리의 다른 하위 폴더로 이동하는 것과 동일하게, 시스템은 LCA를 A로 계산하고 A→C를 활성화한다. 시스템은 A→B 하위 전체를 보존 영역으로 표시한다.

시스템은 사용자가 A→B 상태에서 G를 클릭하는 경우를 처리한다. 파일 시스템에서 완전히 다른 경로의 파일을 클릭하는 것과 동일하게, 시스템은 LCA를 A로 계산하고 A→C→G를 활성화한다. 시스템은 변경 구간을 브레드크럼에서 강조한다.

시스템은 사용자가 B로 돌아가기 버튼을 누르는 경우를 처리한다. 파일 시스템에서 이전 폴더로 돌아가는 것과 동일하게, 시스템은 A→B를 활성화하고, 시스템은 병합 가능 후보를 제안한다. 시스템은 사용자가 승인하면 병합을 수행한다.

### 파일 시스템과의 핵심 차이점

파일 시스템에서는 물리적 파일과 폴더가 경로를 결정하지만, 대화 시스템에서는 논리적 대화 블록과 컨텍스트가 경로를 결정한다. 파일 시스템에서는 파일을 클릭하면 해당 파일의 내용이 표시되지만, 대화 시스템에서는 노드를 클릭하면 해당 노드까지의 전체 대화 맥락이 활성화된다. 이 차이점이 대화 시스템의 핵심 가치를 만든다.

# 38. 중간점검 기록 모음

잠만,, 중간점검: 전환 규칙은 예측 가능해야 한다. 시스템은 동일한 입력에 동일한 결과를 보장해야 한다. 시스템은 비결정적 요소를 제거해야 한다.

잠만,, 중간점검: 스냅샷 저장 비용은 경로 길이에 선형으로 증가한다. 시스템은 저장 빈도와 보존 정책으로 비용을 통제해야 한다.

잠만,, 중간점검: 병합 UX는 사용자에게 부담이 될 수 있다. 시스템은 기본값을 보존으로 두고, 시스템은 명시적 승인으로 병합을 한정해야 한다.

# 39. 용어 일관성 표(문장형)

시스템은 “체크포인트”를 복원 가능한 스냅샷으로 사용한다. 시스템은 “스냅샷”을 불변 데이터로 정의한다. 시스템은 “보존 영역”을 비활성 분기 가시화 레이어로 정의한다. 시스템은 “병합”을 사용자 승인 하의 경로 통합으로 정의한다.

# 40. 맺음말이 아닌 진행 선언

문서는 결론 대신 진행 선언을 기록한다. 시스템은 트리 기반 경로 전환과 체크포인트 복원을 구현한다. 시스템은 데이터 모델, API, UX, 보안, 성능, 테스트, 배포를 아우르는 일관된 설계를 유지한다. 시스템은 데모와 운영으로 가치를 증명한다. 시스템은 로드맵 단계에 따라 점진적으로 확장한다.

