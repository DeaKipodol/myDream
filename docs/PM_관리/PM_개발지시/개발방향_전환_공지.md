# 개발 방향 전환 공지 - CLI 우선 개발 방식 채택

- 발행일: 2025-11-05
- PM: 프로젝트 매니저 (일정 탐정)
- 대상: 아키텍처 개발자, 기술 개발자
- 우선순위: 긴급 (즉시 확인 필요)
- 상태: 최종 확정

---

## 핵심 요약 (3줄)

1. **기존 29개 Phase 계획을 보류하고, CLI 기반 점진적 개발 방식으로 전환합니다.**
2. **순수 로직 검증 → LLM 연결 → UI 구축 순서로 진행하며, 각 단계의 완벽한 검증 후 다음 단계로 이동합니다.**
3. **첫 목표는 터미널 CLI로 트리 구조 대화 시스템의 핵심 로직을 동작시키는 것입니다.**

---

## 1. 왜 방향을 전환하는가 (PM의 의사결정 배경)

### 1.1 기존 계획의 문제점
- 프론트엔드/백엔드/DB를 동시에 개발하는 것은 검증 지연과 재작업 리스크가 높음
- UI를 먼저 만들면 "겉보기에는 잘 작동하는 것 같지만 실제로는 로직이 불완전"한 상태를 만들기 쉬움
- 핵심 알고리즘(트리 구조, LCA, 경로 전환)의 정확성을 조기에 검증하기 어려움

### 1.2 CLI 우선 방식의 장점
- **거짓말 없는 검증**: 명령어 → 결과가 즉각 표시되므로 로직 오류를 즉시 발견 가능
- **빠른 실험**: HTML/CSS/이벤트 리스너 없이 순수 로직만 집중 개발
- **명확한 인터페이스**: 터미널 출력은 명확하고, AI에게 지시하기도 쉬움
- **UI와 로직 분리**: CLI가 완성되면 UI는 CLI 함수를 호출하는 "껍데기"로만 작업 가능

### 1.3 PM의 판단
- 이 프로젝트의 핵심 가치는 "트리 구조 기반 경로 전환"이라는 **알고리즘**에 있음
- 알고리즘이 검증되지 않은 상태에서 UI를 만드는 것은 모래 위의 성을 짓는 것
- **따라서 CLI로 알고리즘을 먼저 완성하고, 그 위에 UI를 얹는 방식이 실패 확률을 낮춘다**

---

## 2. 새로운 개발 로드맵 (3단계)

### Phase CLI-1: 순수 로직 구현 (LLM 없이)
**목표**: 트리 구조와 경로 전환 알고리즘의 완벽한 동작 검증

**기간**: 1-2주

**산출물**:
- Python CLI 프로그램 (`cli.py`)
- 명령어 인터페이스:
  ```bash
  # 노드 생성
  > create_node parent_id content role

  # 트리 출력
  > show_tree

  # 경로 전환
  > switch_path target_node_id

  # 현재 활성 경로 출력
  > show_active_path

  # 체크포인트 생성
  > create_checkpoint reason

  # 체크포인트 복원
  > restore_checkpoint checkpoint_id
  ```

**핵심 검증 항목**:
- [ ] 트리 구조가 올바르게 생성되고 유지되는가?
- [ ] LCA 계산이 정확한가?
- [ ] 경로 전환 시 활성 경로가 올바르게 재구성되는가?
- [ ] 체크포인트 저장/복원이 정확한가?
- [ ] 보존 영역(shelves) 관리가 올바른가?

**완료 기준**:
- 모든 명령어가 예상대로 동작
- 단위 테스트 작성 및 통과 (핵심 함수 100% 커버리지)
- 엣지 케이스 처리 (순환 참조 차단, 존재하지 않는 노드 참조 등)

---

### Phase CLI-2: LLM 연결 (간단하게)
**목표**: 컨텍스트 블록이 LLM에 제대로 전달되고, 응답이 새 노드로 추가되는지 검증

**기간**: 1주

**산출물**:
- LLM 프로바이더 추상화 레이어 (`llm_provider.py`)
- 더미 LLM 구현 (테스트용)
- 실제 LLM API 통합 (OpenAI 또는 Anthropic)
- 명령어 추가:
  ```bash
  # AI 응답 생성 (현재 활성 경로를 컨텍스트로 사용)
  > ask "사용자 질문"

  # 컨텍스트 블록 출력 (디버깅용)
  > show_context
  ```

**핵심 검증 항목**:
- [ ] 활성 경로의 노드들이 올바른 순서로 컨텍스트 블록에 포함되는가?
- [ ] LLM 응답이 새 노드로 추가되고, 부모-자식 관계가 올바른가?
- [ ] 경로 전환 후 컨텍스트가 올바르게 변경되는가?
- [ ] 토큰 한도 초과 시 처리가 올바른가?

**완료 기준**:
- CLI에서 AI와 실제 대화 가능
- 경로 전환 후 AI가 이전 경로의 내용을 참조하지 않음 (컨텍스트 격리 검증)

---

### Phase CLI-3: CLI 완성 (모든 기능)
**목표**: 설계서에 명시된 모든 핵심 기능을 CLI로 구현

**기간**: 1-2주

**산출물**:
- 병합 기능 (사용자 승인 포함)
- 보존 스레드 관리
- 스냅샷 해시 검증
- 이벤트 로그
- 명령어 추가:
  ```bash
  # 병합 후보 조회
  > show_merge_candidates

  # 병합 승인
  > merge_branch branch_id

  # 보존 스레드 목록
  > show_shelves

  # 이벤트 로그 출력
  > show_events
  ```

**완료 기준**:
- 모든 핵심 기능이 CLI로 동작
- 통합 테스트 통과
- 성능 측정 (경로 전환 지연, LCA 계산 시간 등)

---

### Phase UI-1: 최소 UI 프로토타입
**목표**: CLI가 완성된 후, UI를 "껍데기"로 구축

**기간**: 2-3주

**산출물**:
- HTML/CSS/JS 기반 프론트엔드
- 트리 뷰 (시각화)
- 대화 뷰
- 브레드크럼
- UI는 CLI 함수를 API로 호출 (백엔드 FastAPI로 CLI 함수 노출)

**완료 기준**:
- CLI의 모든 기능이 UI에서 클릭으로 작동
- 시각적 피드백 (하이라이트, 애니메이션 등)

---

## 3. 개발 우선순위와 제약사항

### 3.1 최우선 작업 (Phase CLI-1)
1. **트리 자료구조 구현**
   - Node 클래스: `id, parent_id, content, role, children_ids, created_at`
   - Tree 클래스: `root_id, nodes (dict)`
   - 메서드: `add_node()`, `get_path(node_id)`, `get_children(node_id)`

2. **LCA 알고리즘 구현**
   - 선형 방법 (부모 포인터 따라 올라가기)
   - 시간 복잡도: O(h) (h는 트리 높이)

3. **경로 전환 로직**
   - `switch_path(current_leaf_id, target_id)` 함수
   - LCA 계산 → prefix + suffix 재구성 → active_path 업데이트

4. **체크포인트 시스템**
   - Checkpoint 클래스: `id, active_path_ids, timestamp, snapshot_hash`
   - `create_checkpoint()`, `restore_checkpoint(id)` 함수

5. **CLI 인터페이스**
   - REPL (Read-Eval-Print Loop) 구현
   - 명령어 파싱 및 실행

### 3.2 기술 제약사항
- **언어**: Python 3.10 이상
- **의존성 최소화**: 초기에는 표준 라이브러리만 사용 (LLM 연결 시에만 외부 라이브러리 추가)
- **데이터 저장**: Phase CLI-1에서는 메모리 내 자료구조 사용 (파일 저장은 CLI-2 이후)
- **테스트**: pytest 사용, 핵심 함수는 반드시 단위 테스트 작성

### 3.3 하지 말아야 할 것
- ❌ UI 먼저 만들지 않기 (CLI가 완성되기 전까지)
- ❌ DB 연결하지 않기 (CLI-1에서는 메모리만 사용)
- ❌ 복잡한 최적화 하지 않기 (Binary Lifting은 CLI-3 이후)
- ❌ 설계서의 모든 기능을 한 번에 구현하지 않기 (단계별로)

---

## 4. CLI 개발 시 주의사항

### 4.1 "UI 인터페이스 계약" 동시 작성
CLI 함수를 만들 때마다 주석으로 "UI에서는 이렇게 사용될 것"을 명시하세요.

**예시**:
```python
def switch_path(tree, current_leaf_id, target_id):
    """
    경로를 전환합니다.

    Args:
        tree: Tree 객체
        current_leaf_id: 현재 활성 경로의 리프 노드 ID
        target_id: 전환할 목표 노드 ID

    Returns:
        {
            'active_path_ids': [...],
            'lca_node_id': '...',
            'shelved_path_ids': [...]
        }

    UI 계약:
        - 사용자가 트리 뷰에서 노드 클릭 시 이 함수 호출
        - 반환된 active_path_ids로 ChatView 재렌더링
        - shelved_path_ids는 보존 스레드 패널로 이동
    """
    # ... 구현
```

### 4.2 출력 형식의 일관성
CLI 출력은 사람이 읽기 쉬워야 하지만, 나중에 UI로 변환하기도 쉬워야 합니다.

**권장 형식**:
```python
# 좋은 예: 구조화된 출력
>>> show_tree
Tree:
  A (root)
  ├── B
  │   ├── D
  │   └── F
  └── C
      └── G

Active Path: A → B → D

# 나쁜 예: 애매한 출력
>>> show_tree
Tree has 6 nodes. Current path is A-B-D.
```

### 4.3 테스트 데이터 생성 함수
CLI 테스트를 위해 샘플 트리를 빠르게 생성하는 함수를 먼저 만드세요.

**예시**:
```python
def create_sample_tree():
    """
    테스트용 샘플 트리 생성:
    A
    ├── B
    │   ├── D
    │   └── F
    └── C
        └── G
    """
    tree = Tree()
    tree.add_node(Node(id='A', parent_id=None, content='루트'))
    tree.add_node(Node(id='B', parent_id='A', content='B 내용'))
    tree.add_node(Node(id='C', parent_id='A', content='C 내용'))
    # ...
    return tree
```

---

## 5. PM의 기대사항과 체크포인트

### 5.1 일일 체크포인트 (Phase CLI-1 기간)
- **매일 오후 6시**: 진행 상황 간단 보고 (Slack/이메일)
  - 오늘 완성한 기능
  - 오늘 발견한 이슈
  - 내일 작업할 내용

### 5.2 주간 체크포인트
- **매주 금요일**: PM과 1:1 미팅 (30분)
  - 데모 (CLI 실행 화면 공유)
  - 블로커 논의
  - 다음 주 계획 조율

### 5.3 PM이 확인할 것
- ✅ 명령어를 실제로 쳐보고 결과를 확인
- ✅ 엣지 케이스를 직접 테스트
- ✅ 코드 리뷰 (가독성, 테스트 커버리지)

---

## 6. 다음 액션 (즉시 시작)

### 6.1 아키텍처 개발자
- [ ] 트리 자료구조 설계 (Node, Tree 클래스)
- [ ] LCA 알고리즘 선택 및 의사코드 작성
- [ ] 경로 전환 로직 의사코드 작성
- [ ] 데이터 저장 방식 결정 (JSON 파일? Pickle? SQLite?)
- [ ] **산출물**: `docs/아키텍처설계/CLI_아키텍처.md` (설계 문서)

### 6.2 기술 개발자
- [ ] Python 개발 환경 설정 (가상환경, pytest 설치)
- [ ] 프로젝트 디렉토리 구조 생성:
  ```
  myDream/
  ├── cli/
  │   ├── __init__.py
  │   ├── cli.py          # REPL 메인
  │   ├── tree.py         # 트리 자료구조
  │   ├── lca.py          # LCA 알고리즘
  │   ├── checkpoint.py   # 체크포인트 시스템
  │   └── commands.py     # 명령어 핸들러
  ├── tests/
  │   ├── test_tree.py
  │   ├── test_lca.py
  │   └── test_checkpoint.py
  └── README_CLI.md       # CLI 사용법
  ```
- [ ] 첫 명령어 구현: `create_node`, `show_tree`
- [ ] 테스트 작성: `test_tree.py` (노드 생성/조회 테스트)

### 6.3 PM (나)
- [ ] Phase CLI-1 상세 개발지시서 작성
- [ ] 샘플 트리 시나리오 정의 (테스트 케이스용)
- [ ] 주간 체크포인트 일정 조율

---

## 7. 리스크 및 대응

### 리스크 1: CLI에 빠져서 UI를 영원히 안 만듦
- **대응**: Phase CLI-3 완료 후 즉시 Phase UI-1 시작 (PM이 강제)
- **지표**: CLI 완성 후 2주 내 UI 프로토타입 시작

### 리스크 2: LLM API 비용 초과
- **대응**: Phase CLI-2에서 더미 LLM으로 먼저 테스트, 실제 API는 최소 호출
- **예산**: 초기 개발 단계에서는 월 $50 이내

### 리스크 3: CLI 로직이 UI로 이식될 때 문제 발생
- **대응**: CLI 함수 설계 시 UI 계약을 항상 주석으로 명시
- **검증**: Phase CLI-3 완료 시 UI 프로토타입 설계 검토 미팅

---

## 8. FAQ (예상 질문)

### Q1: 기존에 작성한 29개 Phase는 버리는 건가요?
**A**: 버리는 게 아니라 **보류**입니다. CLI가 완성된 후 UI/백엔드를 만들 때 참고 자료로 사용합니다. 다만 순서와 우선순위가 크게 바뀐 것입니다.

### Q2: DB는 언제 연결하나요?
**A**: Phase CLI-3 이후입니다. 초기에는 메모리 내 자료구조와 JSON 파일 저장으로 충분합니다. DB 연결은 UI 구축 단계에서 필요할 때 진행합니다.

### Q3: 설계서에 있는 Binary Lifting 같은 최적화는 언제 하나요?
**A**: Phase CLI-3 완료 후, 성능 측정 결과에 따라 결정합니다. 노드 수가 100개 미만이면 선형 LCA로도 충분합니다.

### Q4: AI 통합은 어떤 모델을 사용하나요?
**A**: Phase CLI-2에서 결정합니다. 초기에는 OpenAI GPT-3.5 또는 Anthropic Claude를 권장하며, 추후 로컬 모델도 고려할 수 있습니다.

---

## 9. 참고 문서

- **원본 설계서**: `/Users/kimdaegi/Desktop/myDream/plan.md`
- **마스터 일정표**: `/Users/kimdaegi/Desktop/myDream/docs/PM_관리/PM_일정관리/마스터_일정표.md` (참고용, 현재는 CLI 우선 방식으로 진행)

---

## 10. 승인 및 서명

**PM 의사결정**: CLI 우선 개발 방식을 최종 확정합니다.

**발행자**: 프로젝트 매니저 (일정 탐정)
**발행일**: 2025-11-05
**확인 필요 대상**: 아키텍처 개발자, 기술 개발자
**회신 기한**: 2025-11-05 오후 6시 (문서 확인 및 질문 사항 회신)

---

**다음 문서**: Phase CLI-1 상세 개발지시서 (곧 발행 예정)
