# 노드생성 논의 - 핵심 이슈 정리

## 문서 개요
이 문서는 논의 과정에서 도출된 **핵심 이슈(문제)**들과 각각에 대한 **상황 설명** 및 **해결 방안**을 정리합니다.

---

## 이슈 1: 역할 분리 문제 (Model A의 치명적 결함)

### 상황 설명
**Model A의 설계**
```
role 구분 방식:
- 노드 = {"id": "uuid-1", "parentId": "root", "role": "user", "content": "오늘 날씨?"}
- 노드 = {"id": "uuid-2", "parentId": "uuid-1", "role": "ai", "content": "맑습니다"}
```

**사용자의 지적**
- "사용자 질문과 AI 응답을 따로 분리하면 복구할 때 문제가 생긴다"
- 예: A→B→C 대화 후, C 시점(질문 노드)으로 돌아가면, 다음 입력도 질문이 되어 **사용자 질문 2개가 연속 생성**
- 이는 버그를 야기함: `[사용자 질문 1] [AI 응답 1] [사용자 질문 2] [사용자 질문 3]???`

### 핵심 문제
- **의미 단위의 파괴**: 질문 없는 응답, 응답 없는 질문이 생김
- **LLM 컨텍스트 오염**: AI 모델이 이해할 수 없는 대화 구조 전달
- **데이터 일관성**: 트리 구조가 의미적으로 깨짐

### 해결 방안 ✅
**"대화 턴(Turn)"을 기본 단위로 삼기**
- 1턴 = 사용자 질문(user_question) + AI 응답(ai_answer)
- 이 쌍을 **하나의 노드**로 통합
- 결과: `parentId`를 따라가면 항상 완전한 대화 히스토리 복원 가능

---

## 이슈 2: 버퍼 관리와 분기 보존 딜레마

### 상황 설명 (시나리오)

**초기 상황**
```
대화 진행: A 턴 → B 턴 → C 턴
현재 상태: current_node_id = node_C
버퍼: 비어있음 (이미 저장됨)
```

**사용자 행동**
```
1. C 턴 완료 후, B 시점으로 되돌아가기: /goto B
2. 새로운 대화 시작: D 질문 입력
```

**초기 설계의 문제점**
```
[Model A 방식 (Message Block)]

/goto B 실행 시:
- current_node_id = node_B로 변경
- current_messages_buffer = [] (버퍼 비움)
- ❌ C 대화는 어디로? 트리에 저장 안 됨!

결과: 트리 구조는 A→B 로만 보임
     (C 분기 사라짐)
```

### 핵심 문제
- **/goto 시 버퍼가 버려짐**
- 모든 분기가 보존되지 않음
- `shelves` 같은 임시 저장소 필요 (복잡도 증가)

### 첫 번째 시도 (실패): shelves 모델

**설계**
```python
shelves = {}  # {node_id: [[대화], [대화], ...]}

/goto B:
  현재 버퍼 C를 shelves["node_C"] 저장
  current_node_id = node_B로 변경
  버퍼 비움

/restore:
  shelves에서 복구해서 다시 시작
```

**왜 실패했는가?**
- `shelves`는 임시 저장소일 뿐, 트리 구조에 반영 안 됨
- A→B→C, A→B→E 처럼 여러 분기가 있을 때, 정확히 어떤 분기로 갈지 불명확
- 복구 메커니즘이 불안정함

### 해결 방안 ✅ (자동 노드 생성)

**핵심 아이디어**
- **"모든 대화는 즉시 노드로 생성되어 트리에 저장"**
- `/save`는 "저장"이 아니라 **"이름표 붙이기"**
- `/goto`는 **"단순 위치 이동"** (자동 저장 로직 불필요)

**동작 흐름**
```python
1. 사용자: "D 질문 입력"
   → AI 응답 생성
   → node_D 즉시 자동 생성 (parentId: node_B)
   → all_nodes 트리에 영구 저장 ✅
   → current_node_id = node_D

2. 사용자: /goto B
   → current_node_id = node_B로 변경만 함
   → 버퍼 로직 필요 없음!

결과:
    root
     |
   node_A
     |
   node_B
     |
     +-- node_C  ✅ 보존됨
     |
     +-- node_D  ✅ 보존됨
```

---

## 이슈 3: 노드 분할과 경로 지정의 모호함

### 상황 설명

**사용자의 질문**
- "A[a, b] B 사이에서 분기하고 싶은데, a와 b 사이 지점을 어떻게 명시할 건가?"
- 의도: 노드 A 내부의 여러 턴 중에서 특정 위치 이후로 분기하고 싶음

### 핵심 문제
- **"하나의 노드 내부의 특정 메시지 뒤로 분기"** 요청
- 이를 지원하려면:
  1. 노드 ID + 메시지 인덱스(index)가 필요
  2. `/goto A 3` 같은 문법 필요
  3. 해당 시점에서 노드 분할(Node Splitting) 로직 필요
  4. 구현 복잡도 급증 ↑

### 모델별 비교

**Model B (1턴 = 1노드)의 관점**
```
A[a, b] B 표현:

node_a (1턴)
  |
node_b (1턴)
  |
node_c (1턴) ← B를 나타냄

"a와 b 사이" = node_a 자신
"a와 b 사이에서 분기" = node_a로 /goto B한 후, 새 대화 시작
                    → 새 노드가 node_a의 자식으로 자동 생성
```

### 해결 방안 ✅

**설계 결정: Model B 채택**
- 1턴 = 1노드 (모든 턴이 명시적인 노드)
- "a와 b 사이"는 개념적으로 존재하지 않음
- 대신 "node_a 시점"으로 표현
- 분기는 다음 턴부터 자동으로 처리

**실제 터미널 사용**
```
1. A 턴 완료 (node_A 자동 생성)
2. B 턴 완료 (node_B 자동 생성, parentId: node_A)
3. /save checkpoint_B (node_B에 이름표)
4. C 턴 완료 (node_C 자동 생성, parentId: node_B)
5. 분기 원함: /goto checkpoint_B
6. D 질문 입력 (node_D 자동 생성, parentId: node_B) ✅
```

---

## 이슈 4: "/save" 명령의 의미 재정의

### 상황 설명

**초기 개념**
```
/save checkpoint_name
  → 현재 버퍼를 노드로 생성
  → 노드에 이름 붙임
  → checkpoints[name] = node_id
```

**사용자의 재해석**
- "AI에게 질문하고 응답 받는 순간 자동으로 저장되어야 한다"
- `/save`는 "저장"이 아니라 **"이미 저장된 것에 이름표 붙이기"**

### 핵심 문제
- **/save의 역할 혼동**
  - 초기: "데이터 저장" (파일시스템의 Save와 동일)
  - 변경 후: "즐겨찾기/체크포인트 등록" (Git의 Tag와 유사)

### 해결 방안 ✅

**명확한 역할 분리**

| 동작 | 발생 시점 | 담당자 | 결과 |
|------|---------|--------|------|
| **자동 노드 생성** | 매 턴마다 (Q+A) | 시스템 | all_nodes에 추가 |
| **/save (이름표)** | 사용자 명령 | 사용자 | 현재 노드를 checkpoints에 등록 |
| **/goto (이동)** | 사용자 명령 | 사용자 | current_node_id 변경 |

**코드 개선**
```python
# Before (혼동됨)
/save checkpoint_name:
  버퍼를 노드로 생성? 아니면 이름만 붙이기?

# After (명확함)
/save checkpoint_name:
  현재 노드 ID (이미 저장됨)에 이름 붙이기만
  checkpoints[checkpoint_name] = current_node_id
```

---

## 이슈 5: 메시지 블록 vs 개별 턴 모델 선택

### 상황 설명

**Message Block 모델** (초기)
```
노드 = {
  "id": "node_A",
  "messages_list": [
    {"role": "user", "content": "질문1"},
    {"role": "assistant", "content": "답변1"},
    {"role": "user", "content": "질문2"},
    {"role": "assistant", "content": "답변2"}
  ]
}
```

**개별 턴 모델** (최종)
```
노드_1 = {
  "id": "node_1",
  "user_question": "질문1",
  "ai_answer": "답변1"
}

노드_2 = {
  "id": "node_2",
  "parentId": "node_1",
  "user_question": "질문2",
  "ai_answer": "답변2"
}
```

### 핵심 문제

**Message Block의 장점**
- LLM API에 바로 `messages_list` 전달 가능
- "체크포인트 사이의 대화" 개념이 명확

**Message Block의 단점**
- 블록 내부의 특정 메시지 뒤로 분기하려면 **노드 분할(Node Splitting)** 필요
- 분할 로직이 복잡
- 버퍼 관리가 필요
- A→B→C 분기가 자동 보존 안 됨

**개별 턴 모델의 장점**
- 모든 분기가 자동으로 보존됨 ✅
- 분기 로직이 단순 (새 턴 = 새 노드)
- LLM API 호출도 간단 (`get_context_path()` 사용)
- 버퍼 로직 불필요

**개별 턴 모델의 단점**
- 노드가 많아질 수 있음 (메모리 오버헤드 미미)
- LLM에 전달할 때 모든 노드를 순회해야 함 (성능 영향 미미)

### 해결 방안 ✅

**개별 턴 모델 채택**

**이유**
1. **자동 분기 보존**: 버퍼 로직 최소화
2. **단순성**: `/goto` 시 복잡한 자동 저장 로직 필요 없음
3. **명확성**: 각 노드의 의미가 명확 (1노드 = 1대화 턴)
4. **확장성**: UI(클릭) → 터미널(ID 입력) 전환 시에도 동일한 로직 사용

---

## 이슈 6: 이름 없는 노드(Unnamed Nodes)의 역할

### 상황 설명

**현황**
```
checkpoints = {
  "A": node_A_id,
  "B": node_B_id,
  "D": node_D_id
}

all_nodes에는 다음도 포함:
- node_C (분기되었지만 /save로 이름표 붙이지 않음)
```

**사용자의 질문**
- "C는 C가 아니라 B가 되는 건가?"
- "이름 없는 노드가 뭐냐?"

### 핵심 문제
- **개념 혼동**: "이름 없음" = "존재하지 않음" ?
- 실제: "이름 없음" = "checkpoints에 등록 안 됨" (트리에는 존재)

### 해결 방안 ✅

**명확한 정의**

| 특성 | 이름 있는 노드 | 이름 없는 노드 |
|------|-----------|-----------|
| **저장 위치** | all_nodes O, checkpoints O | all_nodes O, checkpoints X |
| **트리 구조** | ✅ 포함됨 | ✅ 포함됨 |
| **접근 방법** | `/goto name` | `/list_children` 후 ID 복사 |
| **예시** | "/save B" | 자동 생성되는 모든 분기 노드 |
| **비유** | Git: 태그 달린 커밋 | Git: 태그 안 달린 커밋 |

**중요**
- C는 **여전히 B의 자식 노드**
- C는 **트리에 영구 보존됨**
- C는 단지 **checkpoints 딕셔너리에 등록 안 되었을 뿐**

---

## 종합 요약

| 이슈 | 초기 문제 | 최종 해결 |
|------|---------|---------|
| **이슈 1** | role 분리 → 버그 | 1턴 = 1노드 (Q+A 통합) |
| **이슈 2** | 버퍼 분기 손실 | 자동 노드 생성 → 항상 보존 |
| **이슈 3** | 경로 지정 모호 | 1턴 모델 선택 → 명확 |
| **이슈 4** | `/save` 역할 혼동 | "저장"이 아닌 "이름표 붙이기" |
| **이슈 5** | 블록 vs 턴 선택 | 턴 모델 채택 |
| **이슈 6** | 이름 없는 노드 의미 | "checkpoints 미등록" 노드 |

---

## 최종 아키텍처

```
자료구조:
- all_nodes: 모든 노드 (이름 유무 상관없이)
- checkpoints: 이름표만 관리
- current_node_id: 현재 위치

규칙:
1. 매 턴마다 자동으로 노드 생성 및 all_nodes에 추가
2. /save = 현재 노드에 이름표 추가 (checkpoints에 등록)
3. /goto = 현재 위치 변경만 수행
4. 모든 분기는 영구 보존됨

결과:
✅ 데이터 유실 없음
✅ 분기 자동 보존
✅ 구현 간단
✅ LLM 통합 용이
```
