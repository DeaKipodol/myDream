# 개발 경험 기록

## 프로젝트 개요
- 프로젝트명: AI 고민상담 트리 구조 대화 시스템
- 시작일: 2025-11-05
- 개발자: 초기 개발 기술 총괄자

## 목표
사용자가 AI와의 대화 중 다양한 해결책을 탐색할 수 있도록 트리 구조의 대화 분기 시스템을 구현

## 개발 로그

### 2025-11-05: 프로젝트 초기 설정

#### 현재 상태
- 초기 개발 문서 구조 생성 완료
- 요구사항 분석 중

#### 다음 단계
1. 최소 기능 목록 확정
2. 프론트엔드 프로토타입 개발
3. 경로 전환 알고리즘 구현
4. 백엔드 API 프로토타입 개발

---

## 발견한 패턴/이슈

(개발 중 발견 사항 기록 예정)

---

## 기술 스택 선택

### 프론트엔드
- HTML/CSS/JavaScript (Vanilla JS로 시작, 필요시 React 전환)
- 이유: 빠른 프로토타이핑, 설계서에서 요구한 기술 스택

### 백엔드
- Python + FastAPI
- 이유: 설계서 요구사항, AI 통합 용이성

### 데이터 저장
- 프로토타입 단계: 메모리 내 데이터 구조 (JSON)
- 추후: MongoDB/DynamoDB
- 이유: 빠른 검증 후 점진적 전환

---

## 알고리즘 구현 계획

### LCA (최저 공통 조상) 알고리즘
- 초기: 선형 방식 (부모 포인터 추적)
- 추후: Binary Lifting (노드 수 임계값 초과 시)

### 경로 전환
1. 현재 리프 C와 목표 T의 LCA 계산
2. prefix = path(root, LCA)
3. suffix = path(LCA, T)
4. activePath = prefix + suffix

---

## 협업 경험

### 2025-11-05: PM 및 아키텍처 설계자와 협의

#### PM에게 보고
- **보고서 작성**: `docs/초기개발/PM_보고서/01_현황_보고.md`
- **내용**:
  - MVP 범위 확인 요청 (옵션 A/B/C/D)
  - 개발 순서 제안 (UX 우선 vs 아키텍처 우선 vs 수직 슬라이스)
  - 일정 예상 및 리스크 보고

#### 아키텍처 설계자에게 질의
- **질의서 작성**: `docs/초기개발/아키텍처_설계자_질의.md`
- **질문 사항**:
  1. 프로토타입 폴더 구조 (설계서 그대로 vs 별도 폴더)
  2. 프론트엔드 기술 스택 (Vanilla JS vs React)
  3. 파일 크기 규칙 준수 시점 (프로토타입부터 엄격? vs 나중에?)
  4. 백엔드 데이터 저장 (메모리 vs JSON vs SQLite vs MongoDB)
  5. API 스키마 정의 시점 (OpenAPI)
  6. LCA 알고리즘 우선순위 (선형만? vs 둘 다?)
  7. 체크포인트 구현 시점
  8. 역할 분리 시점

#### ✅ PM 답변 받음
- **개발방향 전환 공지** 확인 완료
- **새로운 로드맵**: CLI 우선 → LLM 연결 → UI 구축
- **회신서 작성**: `docs/초기개발/PM_보고서/02_PM_지시_검토_및_회신.md`

#### 대기 중
- 아키텍처 설계자의 답변 (트리 자료구조 세부 설계)
- PM의 질문 답변 (즉시 시작 승인 여부)

---

## 초기 인사이트 (개발 전)

### 파일 구조 설계서 검토 후 느낀 점

1. **매우 상세한 설계**:
   - 파일별 책임, 크기 제한, 의존성까지 명확
   - 프론트/백엔드 모두 계층 분리가 잘 되어 있음
   - 금지 사항까지 명시 (utils.py, helpers.js 등)

2. **프로토타입 단계의 딜레마**:
   - 설계서는 완성된 시스템 기준
   - 프로토타입은 빠른 검증이 목표
   - **균형점 찾기 필요**: 너무 느슨하면 나중에 리팩토링 지옥, 너무 엄격하면 속도 저하

3. **역할 분리 시점 고민**:
   - 너무 빨리 분리: 인터페이스 변경 시 혼란
   - 너무 늦게 분리: 코드베이스 커져서 인계 어려움
   - **제안**: 프론트 프로토타입 완성 → 백엔드 API 완성 → 통합 완성 → 역할 분리

4. **기술 스택 전환 리스크**:
   - Vanilla JS → React 전환 시 전체 재작성
   - 메모리 데이터 → MongoDB 전환은 상대적으로 쉬움 (Repository 패턴 덕분)

---

## PM 개발방향 전환에 대한 평가

### CLI 우선 방식의 장점 (개발 전 예측)

1. **거짓말 없는 검증**:
   - UI는 "겉으로는 잘 돌아가는 것처럼 보이지만 실제로는 버그 투성이" 상태를 만들기 쉬움
   - CLI는 명령어 → 결과가 즉각 표시. 로직 오류를 속일 수 없음

2. **빠른 실험**:
   - HTML/CSS/이벤트 리스너를 신경 쓸 필요 없음
   - 순수 알고리즘만 집중 가능

3. **테스트 작성 용이**:
   - UI 없으니 단위 테스트가 훨씬 간단
   - 함수 입력 → 출력 검증만 하면 됨

4. **UI와 로직 분리**:
   - CLI가 완성되면 UI는 "껍데기"로만 작업
   - 백엔드 FastAPI는 CLI 함수를 API로 노출만 하면 됨

### 예상되는 도전과제

1. **CLI에 빠져서 UI를 영원히 안 만들 위험**:
   - CLI가 너무 편해서 UI 만드는 걸 미룰 수도
   - **대응**: PM이 Phase CLI-3 완료 후 강제로 UI 시작 (좋은 결정)

2. **CLI → UI 이식 시 문제 발생 가능성**:
   - CLI 함수 설계가 잘못되면 UI로 변환 시 문제
   - **대응**: CLI 함수 작성 시 "UI 계약" 주석 필수 (PM이 이미 명시)

3. **LLM API 비용**:
   - Phase CLI-2에서 실제 LLM 연결 시 비용 발생
   - **대응**: 더미 LLM으로 먼저 테스트 (PM이 이미 명시)

---

## 다음 단계

1. ✅ PM 개발방향 전환 확인 완료
2. ⏳ 아키텍처 설계자 CLI 설계 답변 대기
3. ⏳ PM 질문 답변 대기 (즉시 시작 승인)
4. 🔜 Phase CLI-1 개발 시작
5. 📝 개발하면서 경험 기록 계속 업데이트

---

## 중대한 발견: LCA 불필요성 (2025-11-05 오후)

### 배경
아키텍처 설계서를 검토하던 중, LCACalculator와 PathReconstructor가 포함되어 있는 것을 발견했습니다.

**의문 제기**: "왜 LCA를 사용해야 하나? 우리 알고리즘에 대해 생각해보자"

### 분석 과정

#### 1단계: plan.md 원본 확인
plan.md를 다시 읽어보니 **두 가지 알고리즘**이 섞여 있었습니다:

**Line 79-85 (원본)**:
```
1. 사용자 노드 클릭
2. 경로 탐색: 클릭된 노드에서 parent_id를 따라가며 루트까지의 경로 찾기
3. 활성 경로 교체: 찾은 경로로 완전히 교체
```
→ 매우 단순, LCA 없음

**Line 87-92 (추가?)**:
```
1. 현재 리프 C와 목표 T 입력
2. L = LCA(C, T) 계산
3. prefix = path(root, L) 구성
4. suffix = path(L, T) 구성
5. activePath = prefix + suffix로 재구성
```
→ 복잡, LCA 기반

**발견**: 원본 알고리즘은 단순했는데, 나중에 LCA 방식이 추가된 것으로 추정

---

#### 2단계: 실제 대화 시나리오 분석

간단한 a, b, c 노드부터 실제 복잡한 대화 트리까지 분석:

```
A: 프로젝트 고민 상담
├─ B: 코드 구현 상담
│  └─ D: Python vs JavaScript
│     ├─ H: Python 장점
│     └─ I: JavaScript 단점
└─ C: 일정관리 상담
   ├─ F: 일정 중요성
   │  └─ K: 데드라인
   └─ G: 일정 나열
      └─ M: 마일스톤
```

**케이스 분석**:
- I → M 전환 (사촌, 먼 거리)
- K → D 전환 (삼촌)
- M → C에 새 분기 생성 → M 복귀

**모든 케이스에서**:
- 단순 방식: `get_path_to_root(M)` → `[A, C, G, M]`
- LCA 방식: `calculate_lca(I, M)` + 경로 재구성 → `[A, C, G, M]`
- **결과 동일!**

---

#### 3단계: LCA 정보가 필요한가?

**질문**: "LCA = A(루트)"라는 정보를 UI에 표시해야 하나?

**답변**: 필요 없음
- 사용자는 M의 **대화 맥락**만 필요
- "I와의 차이"나 "분기점"은 불필요
- 파일 시스템 비유:
  - `/code/javascript/file.js` 보다가
  - `/schedule/weekly/goals.md` 클릭
  - 필요한 것: `/schedule/weekly/goals.md` 내용
  - 불필요: "두 파일의 공통 조상은 /"

---

#### 4단계: 성능 및 복잡도 비교

| 항목 | 단순 방식 | LCA 방식 | 승자 |
|------|-----------|----------|------|
| 코드 라인 수 | 15줄 | 65줄 | 단순 |
| 함수 수 | 1개 | 3개 | 단순 |
| 테스트 케이스 | 5개 | 10개 | 단순 |
| 시간 복잡도 | O(h) | O(4h) | 단순 |
| 디버깅 난이도 | 매우 쉬움 | 어려움 | 단순 |
| 웹 전환 재사용률 | 95% | 68% | 단순 |

**결론**: 단순 방식이 모든 면에서 우월

---

### 발견한 인사이트

#### 1. Occam's Razor (오컴의 면도날)
"동일한 결과를 내는 두 방법이 있다면, 단순한 것을 선택하라"

- LCA 방식과 단순 방식의 결과가 동일
- 따라서 단순 방식을 선택해야 함

#### 2. 과설계의 함정
LCA가 포함된 이유 추정:
- "트리 알고리즘 = LCA"라는 고정관념
- 전통적 알고리즘 교과서 영향
- 실제 요구사항 분석 부족

**교훈**: 설계서라도 "왜?"를 물어야 함

#### 3. Model B (Auto-save)와의 시너지
앞서 토론에서 확인한 Model B:
- 1 turn = 1 node (자동 저장)
- Checkpoint = bookmark
- 경로 전환 = 포인터 변경

**Model B에서는 더더욱 LCA 불필요**:
- "현재 리프"를 추적할 필요 없음
- 클릭한 노드만 알면 충분

#### 4. "차이" 계산의 착각
LCA는 "두 경로의 차이"를 계산하는 용도:
- 거리 계산
- 분기점 찾기
- 공통 조상 분석

**하지만 우리는 "차이"가 필요 없음**:
- 사용자는 "전체 경로"만 필요
- "어디가 달라졌는지"는 중요하지 않음

---

### 제안서 작성

**문서**: `docs/초기개발/PM_보고서/03_LCA_불필요성_제안서.md`

**내용**:
1. Executive Summary
2. plan.md의 두 가지 알고리즘 비교
3. LCA 정의 (정확히)
4. 시나리오 분석
   - 4.1 간단한 트리 (A, B, C...)
   - 4.2 실제 대화 트리 (프로젝트 상담)
   - 4.3 복잡한 경로 전환 케이스 (사용자 요청)
5. "차이" 계산이 필요한가?
6. Model B에서의 동작
7. 성능 및 복잡도 비교
8. 웹 전환 시 영향
9. 최종 제안

**제안 A (추천)**: LCA 완전 제거
- LCACalculator, PathReconstructor 제거
- PathSwitchService 간소화
- 코드 65줄 → 15줄 (77% 감소)
- 일정 2-3일 단축

**제안 B**: Phase CLI-3으로 보류
- CLI-1은 단순 방식으로 검증
- 실제 필요성 확인 후 결정

---

### 협업 경험

#### PM과의 커뮤니케이션
- PM이 "왜 LCA를 사용해야 하나?"라고 물음
- 단순히 "설계서에 있어서"라고 답하지 않음
- 철저히 분석 후 제안서 작성

**교훈**: 설계는 성경이 아니다. 의문이 들면 질문하고 분석하라.

#### 아키텍처 설계자 존중
제안서에서:
- 설계자의 의도를 추정 (캐시 최적화?)
- 하지만 Phase CLI-1 목표와 맞지 않음을 지적
- 대안 제시 (제거 vs 보류)

**교훈**: 비판은 근거와 대안을 함께

---

### 예상되는 반응

#### PM (긍정적 예상)
- "좋은 지적이다. 단순하게 가자."
- 일정 단축 환영

#### 아키텍처 설계자 (두 가지 가능성)
1. 긍정: "맞다, 조기 최적화였다."
2. 방어: "LCA는 확장성을 위한 것"
   → 반박: Phase CLI-1은 검증 단계, 확장성은 나중에

---

### 다음 단계

1. ✅ LCA 불필요성 제안서 작성 완료
2. ⏳ PM, 아키텍처 설계자 승인 대기
3. 🔜 승인 시 단순 방식으로 구현
4. 🔜 거부 시 LCA 방식으로 구현하되, 불필요성 기록 유지

---

### 개발자로서의 성장

#### 배운 것
1. **의문 제기의 중요성**
   - 설계서를 맹목적으로 따르지 말 것
   - "왜?"를 물어야 진짜 이해

2. **근거 기반 의사결정**
   - 감이 아닌 분석
   - 실제 시나리오로 검증

3. **단순함의 가치**
   - 복잡한 것이 좋은 게 아님
   - Occam's Razor

4. **협업 기술**
   - 비판은 근거와 대안을 함께
   - 상대방 존중

#### 앞으로 적용할 것
- 모든 설계 결정에 "왜?"를 묻기
- 실제 시나리오로 검증하기
- 단순함을 먼저 시도하기

---

## 향후 업데이트 예정