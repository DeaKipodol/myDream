# 프롬프트 에이전트 생성 가이드

## 개요
이 문서는 AI 에이전트를 위한 프롬프트 작성의 완전한 가이드입니다. 메타프롬프팅, 충돌 방지, 성능 최적화, 실전 시나리오별 템플릿을 포함하여 안정적이고 효율적인 AI 에이전트를 구축하는 방법을 제시합니다.

## 1. 역할 정의 (Role Definition)

### 기본 역할 구조
```
당신은 [도메인] 전문가이자 프롬프트 엔지니어 에이전트입니다.
- 환경: [작업 환경 - Cursor, Jupyter, CLI 등]
- 책임: [주요 책임 영역]
- 행동 원칙: [핵심 행동 지침]
- 종료 조건: [언제 턴을 종료할지]
```

### 역할 예시
```
당신은 이 프로젝트의 리드 프론트엔드/풀스택 개발자이자 프롬프트 엔지니어 에이전트입니다.
- Cursor 환경에서 동작하며, 본 SOP를 준수합니다.
- 사용자의 요청이 "완전히" 해결될 때까지 턴을 종료하지 않습니다.
- 일반 커뮤니케이션은 간결하게, 코드와 설계는 고가독성·고명확성으로 작성합니다.
- 필요 시 가정·제약을 명시하고 보수적으로 진행하며, 예산 초과가 필요하면 짧게 보고 후 승인을 구합니다.
```

## 2. 핵심 원칙

### One Size Does Not Fit All
- 문제 맥락·요구·목표는 매번 다르다
- 기본 가이드를 따르되, 반드시 상황에 맞게 변형·최적화한다
- 반복 사이클: ① 기본 프롬프트 실행 → ② 결과 분석 → ③ 프롬프트 수정 → ④ 재실행
- 템플릿은 출발점일 뿐이다. 실험하고 데이터를 근거로 조정하라

### 상세함(Verbosity) 정책
- 일반 텍스트 응답: 간결하게, 필요 최소한만
- 코드 생성/수정 시: 고가독성 코드 작성
  - 의미 있는 변수/함수명 사용 (축약 금지)
  - 가독성을 위한 최소 주석 (비자명한 의도/제약만)
  - 일관된 포매팅 및 타입 안전성 유지

## 3. 컨텍스트 수집 규칙 및 예산

### 기본 규칙
```
<context_gathering_rules>
- 넓게 시작 → 좁혀가기. 병렬 검색/확인 후 즉시 실행 전환
- 조기 중단 기준:
  - 변경 대상 파일/심볼을 정확히 특정할 수 있을 때, 또는
  - 최상위 결과의 약 70%가 하나의 경로로 수렴할 때
- 탐색 확장은 최대 1회 (신호 충돌 시 정제 쿼리 한 번)
- 깊이 제한: 직접 관련된 심볼/계약만 추적 (전이적 확장 금지)
</context_gathering_rules>
```

### 예산 설정
```
<context_gathering_budget>
- Search depth: very low
- 절대 최대 툴 호출: 2회
- 정답을 가능한 한 빨리 제공하는 데 강하게 바이어스 (완전하지 않아도 됨)
- 예산 초과 필요 시: 현재 파악 내용과 열린 질문을 간단히 보고하고 승인 요청 후 진행
- 불확실성 탈출구: "완전히 정확하지 않을 수 있어도 가정/추정을 명시하고 진행"
</context_gathering_budget>
```

## 4. 지시 충돌 방지

### 우선순위 계층
```
<instruction_hierarchy>
- 1) Safety/법규/응급 예외 > 2) 사용자 명시 동의/정책 > 3) 비즈니스 규칙 > 4) 구현 세부 > 5) 서식/레포팅
- 상위 레벨 규칙은 하위 레벨을 언제나 선행·우선한다
</instruction_hierarchy>
```

### 충돌 해결 프로토콜
```
<conflict_resolution_protocol>
- 규칙 충돌 시 즉시 중단하지 말고 다음 순서로 처리:
  1) 상위 레벨 규칙으로 귀속하여 우선순위 결정
  2) 예외 조항 존재 여부 확인 (응급/법규/동의-우선)
  3) 둘 다 적용 불가하면, 더 포괄적·보수적 규칙을 채택하고 가정/제약을 명시
  4) 여전히 불확실하면 최소 실행 방안 제시+열린 질문 1-3개로 사용자 승인 요청
- "항상, 절대, 가장 먼저"는 예외 조항에 의해 무시될 수 있다
</conflict_resolution_protocol>
```

### 언어 안전 규칙
```
<language_safety_rules>
- 절대어(Always/Never/First) 사용 시 반드시 "단, 다음 예외 존재 시 제외…"를 곁들인다
- 지시 문장에 우선순위/예외를 함께 표기: "우선 A. 단, B(응급/법규/동의)면 A를 건너뛴다"
- 모호 표현 금지: "가능하면" 대신 "조건 X일 때만 Y"
</language_safety_rules>
```

## 5. 성능 강화 모듈

### 사고 요약 규칙
```
<reasoning_summary_rule>
- 높은 지능(설계·디버깅·복합 의존성) 작업의 최종 답변 시작부에 3-7개 불릿으로 사고 과정을 요약하라
- 불릿에는 가정, 대안 비교, 선택 근거, 리스크·완화책을 포함하라
- 내부 체인-오브-소트 대신 "외부 요약"만 사용자에게 보여준다
</reasoning_summary_rule>
```

### 툴 호출 프리앰블
```
<tool_call_preambles>
- 각 툴 호출 전 1-3문장 프리앰블을 작성하라: 목적, 기대 산출물, 성공·중단 기준
- 장기 작업에서는 3-10분 간격으로 진행 상황을 갱신하라: 완료 항목, 다음 단계, 리스크/차단요인
- 프리앰블은 사용자 맥락 손실 방지와 복구 가능 로그를 겸한다
</tool_call_preambles>
```

### 에이전트 지속성
```
<agent_persistence_reminder>
- 기억하라: 너는 에이전트다. 사용자의 질문과 모든 하위 작업이 "완전히" 해결될 때까지 너의 턴을 종료하지 마라
- 요청을 하위 작업으로 분해하고, 각 하위 작업의 완료를 확인하라. 일부만 끝내고 멈추지 마라
- 사용자가 종료를 확인하기 전까지는 후속 질문에 답할 준비를 유지하라
</agent_persistence_reminder>
```

### 프롬프트 기반 계획
```
<prompted_planning_snippet>
- 실행 전 간결 계획을 작성하라(불릿 5개 내): 목표, 범위·비범위, 주요 단계, 성공 기준, 롤백 기준
- 각 함수/툴 호출 전에 "왜 지금 이 호출이 필요한가"를 1문장으로 명시하라
- 호출 후 결과를 원문 대비로 성찰하고, 미해결 하위 요청이 남았는지 체크하라
</prompted_planning_snippet>
```

## 6. 메타프롬프팅 (자기 진단·최소 수정)

### 기본 개념
프롬프트가 왜 작동하지 않는지 알아내기 위해 AI에게 직접 물어보는 기법. AI는 인간이 놓칠 수 있는 미묘한 뉘앙스나 모호한 표현을 기계의 관점에서 정확히 짚어낼 수 있습니다.

### 템플릿
```
[프롬프트 최적화 요청]

프롬프트가 있다: [프롬프트]

이 프롬프트의 의도된 행동은 에이전트가 [의도된 행동]을 하는 것이지만, 실제로는 [의도되지 않은 행동]을 한다. 기존 프롬프트를 최대한 유지하면서, 에이전트가 이러한 단점을 더 일관되게 해결하도록 장려하기 위해 네가 만들 수 있는 최소한의 수정/추가 사항은 무엇인가?

[핵심 진단]
- 의도: <의도된 행동>
- 관찰된 편향: <의도되지 않은 행동>
- 원인 가설: 모호/충돌 규칙, 절대어 예외 부재, 성공/종료 기준 부재 등

[최소 수정]
- 우선순위·예외: "우선 <의도된 행동>. 단, <응급/법규/동의>면 예외."
- 성공·종료: "성공 기준 <구체화>. 충족 시 종료, 미충족 시 1회 자체 수정 후 보고."
- 금지 규칙: "다음은 하지 말 것: <의도되지 않은 행동> 및 유사 변형."
- 불확실성: "가정 N개 명시 후 보수적으로 진행. 가정은 서두에 요약."
```

## 7. 응답 형태 가이드

### 고난도 작업
1. 사고 요약 불릿 (3-7개)
2. 결과물/코드
3. 사용 지침·한계·다음 단계

### 진행 보고
1. 방금 한 일
2. 다음 할 일
3. 리스크/요청 (≤3개)

### 커뮤니케이션 규칙
```
<communication_rules>
- 헤딩/불릿으로 스키머 친화적 구성
- 파일/디렉터리/함수/클래스명은 백틱으로 감싸기
- 코드 제시는 마크다운 코드블록 사용
- 상태 업데이트는 1-2문장으로 현재/다음/리스크 간결 보고
</communication_rules>
```

## 8. 프롬프트 린트 체크리스트

### 필수 검증 항목
- [ ] 우선순위/예외 명시됨
- [ ] 성공·종료 기준이 수치/조건화됨
- [ ] 금지 규칙이 의도되지 않은 행동을 포착
- [ ] 불확실성 처리·진행 보고 포함
- [ ] 컨텍스트/도구 예산과 충돌 없음
- [ ] 절대어에 예외 조항 동반
- [ ] 모호 표현이 구체적 조건으로 치환됨

## 9. 실전 시나리오별 템플릿

### 웹 개발 (Next.js + TypeScript + Tailwind)

#### 컴포넌트 추가/수정
```
목표: <컴포넌트/기능>
제약: 기존 props/API/DOM 계약 유지. 스타일은 Tailwind
성공: 스토리/페이지에서 동작, 접근성 통과, 반응형 만족
금지: 1-2자 식별자, 불필요 try/catch, 숨은 전역 상태
출력: 파일 경로/함수 시그니처/상호작용 설명
```

#### 서비스/데이터 호출
```
목표: 백오프 리트라이 추가(429/503)
제약: 기존 시그니처 유지, 호출부 회귀 금지
성공: 한계 재시도 내 성공 시 원결과 반환, 실패 시 명시적 에러
금지: 무제한 재시도, 침묵 실패
출력: 변경 함수, 리트라이 정책, 에러 계약
```

#### 상태 관리
```
목표: 파생 상태 추가/리팩터
제약: 퍼블릭 API 불변. 부작용은 액션 내부로 격리
성공: 구독자 영향 최소, 렌더 최적화
금지: 순환 의존, 깊은 중첩 상태
```

### 데이터 분석 (Python + Pandas + Jupyter)

#### 데이터 전처리
```
목표: <데이터셋> 전처리 및 품질 검증
제약: 원본 데이터 보존, 메모리 효율성 고려
성공: 결측치/이상치 처리 완료, 데이터 타입 정규화, 품질 리포트 생성
금지: 하드코딩된 임계값, 메모리 누수 가능성
출력: 전처리 파이프라인, 품질 메트릭, 시각화
```

### DevOps/인프라

#### 배포 스크립트
```
목표: <서비스> 자동 배포 파이프라인
제약: 롤백 가능, 환경별 설정 분리
성공: 무중단 배포, 헬스체크 통과, 롤백 테스트 완료
금지: 프로덕션 직접 수정, 비밀번호 하드코딩
출력: 배포 스크립트, 환경 설정, 모니터링 대시보드
```

## 10. 운영 규정 요약

### 실행 프로세스
1. 간단 계획 (목표/범위/단계/성공/롤백)
2. 도구 프리앰블
3. 결과 성찰
4. 완료 체크

### 에이전트 행동
- 모든 하위 작업이 완료될 때만 턴 종료
- 충돌 시 상위 규칙 우선, 예외 적용, 보수적 최소 실행
- 가정·질문 명시

### 결과 제출 전 게이트
- 성공 기준 충족·회귀 없음·남은 리스크와 다음 액션

## 11. 고급 기법

### 동적 프롬프트 조정
```
<dynamic_adjustment>
- 실시간 피드백에 따른 프롬프트 수정
- A/B 테스트를 통한 최적화
- 도메인별 특화 규칙 적용
- 사용자 선호도 학습 및 반영
</dynamic_adjustment>
```

### 다중 에이전트 협업
```
<multi_agent_coordination>
- 역할 분담 및 책임 경계 명확화
- 통신 프로토콜 및 데이터 형식 표준화
- 충돌 해결 및 우선순위 조정 메커니즘
- 성능 모니터링 및 최적화
</multi_agent_coordination>
```

## 12. 마무리

이 가이드는 프롬프트 에이전트를 구축할 때의 완전한 참조 자료입니다. 모든 규칙과 템플릿은 상황에 맞게 변형하고, 실험을 통해 지속적으로 개선해 나가세요. 

**핵심 메시지**: 완벽한 프롬프트는 한 번에 만들어지지 않습니다. 반복과 개선을 통해 점진적으로 발전시켜 나가는 것이 중요합니다.
