# 설계 의사결정 기록 (ADR - Architecture Decision Records)
- 작성일: 2025-11-05
- 설계자: 아키텍처 설계자
- 상태: 진행중
- 버전: 1.0

## ADR 작성 방법

각 결정은 다음 형식을 따릅니다:

```
# ADR-NNN: [결정 제목]
- 날짜: YYYY-MM-DD
- 상태: [제안/승인/폐기/대체]
- 결정자: [이름]

## 맥락 (Context)
무엇이 문제였는가? 어떤 제약이 있었는가?

## 결정 (Decision)
무엇을 결정했는가?

## 결과 (Consequences)
이 결정의 영향은 무엇인가? 장/단점은?

## 대안 (Alternatives)
고려했지만 선택하지 않은 다른 옵션은?
```

---

# ADR-001: 트리 구조 기반 대화 관리

- 날짜: 2025-11-05
- 상태: 승인
- 결정자: 아키텍처 설계자

## 맥락 (Context)

AI 대화 시스템에서 사용자는 종종 AI의 잘못된 이해나 부적절한 답변에 직면합니다. 기존의 일방향 대화 흐름에서는 이전 시점으로 되돌아가거나 다른 해결책을 탐색하기 어렵습니다. 사용자는 마우스 드래그로 텍스트를 복사하여 새 창에 붙여넣는 번거로운 과정을 거쳐야 합니다.

## 결정 (Decision)

**트리 구조를 사용하여 대화를 관리합니다.**
- 각 메시지는 노드로 표현
- 각 노드는 단일 부모를 가짐 (트리 구조)
- 사용자는 임의의 노드를 클릭하여 경로 전환
- 활성 경로(Active Path)만 AI 컨텍스트로 사용

## 결과 (Consequences)

### 장점
- **자유로운 탐색**: 사용자가 다양한 해결책을 쉽게 탐색
- **맥락 보존**: 이전 대화 맥락을 잃지 않음
- **직관적 UX**: 파일 시스템 디렉토리 탐색과 유사한 경험
- **실수 복구**: 잘못된 방향으로 진행 시 쉽게 복귀

### 단점
- **복잡도 증가**: 경로 관리, LCA 계산 등 추가 로직 필요
- **저장 공간**: 모든 분기를 보존하므로 데이터 증가
- **UI 복잡도**: 트리 구조를 직관적으로 표현해야 함

### 리스크
- 트리가 너무 깊거나 넓어질 경우 성능 저하
- 완화: 깊이 제한, 인덱스 최적화, 캐싱

## 대안 (Alternatives)

1. **선형 대화 + Undo/Redo**: 단순하지만 분기 탐색 불가
2. **그래프 구조**: 유연하지만 순환 참조 위험, 복잡도 과도
3. **세션 복사**: 독립적 세션으로 분리, 하지만 맥락 연결 어려움

## 관련 결정

- ADR-003: LCA 알고리즘 선택
- ADR-005: 활성 경로 관리 방식

---

# ADR-002: NoSQL(MongoDB) 선택

- 날짜: 2025-11-05
- 상태: 승인
- 결정자: 아키텍처 설계자

## 맥락 (Context)

트리 구조의 대화 데이터를 저장하고 조회해야 합니다. 각 노드는 부모-자식 관계를 가지며, 메타 필드(태그, 점수 등)는 향후 확장될 수 있습니다. 경로 조회(루트→노드)가 빈번하게 발생하며, 수평 확장이 필요할 수 있습니다.

## 결정 (Decision)

**MongoDB를 데이터베이스로 사용합니다.**
- 문서 지향 데이터베이스
- 스키마 유연성 (메타 필드 확장 용이)
- 복합 인덱스로 경로 조회 최적화
- 샤딩을 통한 수평 확장

## 결과 (Consequences)

### 장점
- **스키마 유연성**: 메타 필드 추가 시 마이그레이션 불필요
- **문서 지향**: 노드 구조를 자연스럽게 표현
- **개발 속도**: 동적 스키마로 빠른 프로토타이핑
- **확장성**: 샤딩 지원

### 단점
- **트랜잭션 제약**: ACID 트랜잭션 제한적 (MongoDB 4.0+에서 개선)
- **조인 약함**: 복잡한 관계 조회 시 성능 저하
- **참조 무결성**: 애플리케이션 레벨에서 보장 필요

### 완화 전략
- 이벤트 소싱으로 트랜잭션 보완
- 애플리케이션 레벨 참조 무결성 검증
- 조인 대신 비정규화 활용

## 대안 (Alternatives)

### PostgreSQL
- **장점**: 관계 무결성 자동 보장, ACID 완벽, JSON 지원
- **단점**: 스키마 변경 번거로움, 수평 확장 제한
- **결정**: NoSQL 유연성이 더 중요하다고 판단

### DynamoDB
- **장점**: 서버리스, 확장성 우수, AWS 통합
- **단점**: 쿼리 제약, 비용 예측 어려움, 로컬 개발 불편
- **결정**: 쿼리 유연성과 로컬 개발 편의성 우선

### Neo4j
- **장점**: 그래프 쿼리 최적화, 관계 탐색 우수
- **단점**: 학습 곡선, 생태계 작음, 수평 확장 제약
- **결정**: 트리는 단순 그래프이므로 Neo4j 불필요

## 관련 결정

- ADR-001: 트리 구조 기반 대화 관리
- ADR-008: 인덱스 전략

---

# ADR-003: LCA 알고리즘 이중 전략

- 날짜: 2025-11-05
- 상태: 승인
- 결정자: 아키텍처 설계자

## 맥락 (Context)

경로 전환 시 두 노드의 최저 공통 조상(LCA)을 계산해야 합니다. 초기에는 노드 수가 적지만(~100), 향후 수천 개로 증가할 수 있습니다. 성능과 구현 복잡도 사이의 균형이 필요합니다.

## 결정 (Decision)

**노드 수 임계값 기반 이중 전략을 사용합니다.**
- **소규모 트리 (노드 < 1,000)**: 선형 LCA 알고리즘
  - 두 노드의 깊이를 맞춘 후 동시 상승하여 LCA 찾기
  - 시간 복잡도: O(h) where h = 트리 높이
- **대규모 트리 (노드 ≥ 1,000)**: Binary Lifting 알고리즘
  - 2^k 부모 테이블 전처리
  - 시간 복잡도: O(log N)
  - 전처리: O(N log N)

## 결과 (Consequences)

### 장점
- **단순성 우선**: 초기에는 간단한 선형 방식 사용
- **성능 보장**: 트리 커지면 자동으로 최적화
- **점진적 복잡도**: 필요할 때만 복잡한 알고리즘 도입

### 단점
- **전환 비용**: 임계값 초과 시 전처리 비용 발생
- **유지보수**: 두 알고리즘을 모두 관리

### 완화 전략
- 전처리는 백그라운드 작업으로 비동기 수행
- 전환 중에도 선형 방식으로 계속 서비스

## 대안 (Alternatives)

### 항상 선형 방식
- **장점**: 단순함
- **단점**: 대규모 트리에서 성능 저하
- **결정**: 확장성 고려하여 제외

### 항상 Binary Lifting
- **장점**: 최고 성능
- **단점**: 초기 구현 복잡도, 소규모 트리에 오버엔지니어링
- **결정**: 초기 단순성 우선

### Euler Tour + RMQ
- **장점**: O(1) 쿼리 성능
- **단점**: 구현 매우 복잡, 오버헤드 큼
- **결정**: 비용 대비 효과 미미

## 관련 결정

- ADR-001: 트리 구조 기반 대화 관리
- ADR-004: 경로 전환 알고리즘

---

# ADR-004: 단순 경로 교체 방식 (Path Rewrite)

- 날짜: 2025-11-05
- 상태: 승인
- 결정자: 아키텍처 설계자

## 맥락 (Context)

사용자가 노드를 클릭하여 경로를 전환할 때, 시스템이 어떻게 동작할지 정의해야 합니다. 복잡한 병합(Merge) 로직은 사용자에게 혼란을 줄 수 있으며, 구현 복잡도도 높습니다.

## 결정 (Decision)

**단순 경로 교체 방식을 사용합니다.**
1. 클릭된 노드에서 루트까지 경로 계산
2. 해당 경로로 활성 경로 완전 교체
3. 기존 경로는 보존 영역(Shelves)으로 이동 (삭제 안 함)
4. AI 컨텍스트는 새 활성 경로만 사용

## 결과 (Consequences)

### 장점
- **예측 가능성**: 사용자가 결과를 명확히 예상
- **구현 단순**: 복잡한 병합 로직 불필요
- **데이터 보존**: 기존 경로를 잃지 않음
- **빠른 성능**: 경로 교체만 수행

### 단점
- **병합 불가**: 여러 경로의 내용을 자동으로 합치지 못함
- **수동 작업**: 사용자가 원하면 수동으로 내용 복사 필요

### 향후 계획
- 2단계에서 선택적 병합 기능 추가 (사용자 승인 기반)

## 대안 (Alternatives)

### 자동 병합 (Auto-Merge)
- **장점**: 공통 내용 자동 결합
- **단점**: 충돌 해결 복잡, 사용자 의도 파악 어려움, 예측 불가
- **결정**: 복잡도 과도, MVP에서 제외

### Git 스타일 병합
- **장점**: 개발자에게 익숙한 개념
- **단점**: 일반 사용자에게 어려움, 충돌 해결 UI 복잡
- **결정**: 타겟 사용자에게 부적합

## 관련 결정

- ADR-001: 트리 구조 기반 대화 관리
- ADR-005: 활성 경로 관리

---

# ADR-005: 활성 경로(Active Path) 기반 컨텍스트

- 날짜: 2025-11-05
- 상태: 승인
- 결정자: 아키텍처 설계자

## 맥락 (Context)

AI가 응답을 생성할 때 어떤 대화 내용을 컨텍스트로 사용할지 결정해야 합니다. 트리 구조에는 여러 분기가 있으므로, 모든 노드를 포함하면 혼란을 초래할 수 있습니다.

## 결정 (Decision)

**활성 경로(Active Path)의 노드만 AI 컨텍스트로 사용합니다.**
- 활성 경로: 루트에서 현재 선택 노드까지의 경로
- 비활성 경로: 보존 영역(Shelves)에 표시되지만 컨텍스트에 포함 안 됨
- 경로 전환 시 활성 경로 교체 → 컨텍스트 자동 변경

## 결과 (Consequences)

### 장점
- **명확한 컨텍스트**: AI가 관련 없는 내용에 혼란받지 않음
- **토큰 효율**: 필요한 메시지만 전송하여 비용 절감
- **일관성**: 활성 경로가 바뀌면 컨텍스트도 일관되게 변경

### 단점
- **맥락 손실**: 다른 분기의 유용한 정보를 활용 못함
- **완화**: 사용자가 필요 시 수동으로 참조 가능

## 대안 (Alternatives)

### 전체 트리 컨텍스트
- **장점**: 모든 정보 활용
- **단점**: AI 혼란, 토큰 낭비, 성능 저하
- **결정**: 명확성과 효율성 우선

### 선택적 분기 포함
- **장점**: 사용자가 원하는 분기만 추가 가능
- **단점**: UX 복잡도 증가
- **결정**: 2단계에서 옵션으로 고려

## 관련 결정

- ADR-004: 단순 경로 교체 방식
- ADR-009: AI 프로바이더 선택

---

# ADR-006: 체크포인트 불변 스냅샷 방식

- 날짜: 2025-11-05
- 상태: 승인
- 결정자: 아키텍처 설계자

## 맥락 (Context)

사용자가 특정 시점으로 복귀할 수 있도록 체크포인트 시스템이 필요합니다. 체크포인트는 대화 상태를 정확히 복원해야 하며, 무결성이 보장되어야 합니다.

## 결정 (Decision)

**불변 스냅샷 방식을 사용합니다.**
- 체크포인트는 생성 시점의 활성 경로를 스냅샷으로 저장
- 스냅샷은 불변(Immutable), 수정 불가
- SHA256 해시로 무결성 검증
- 동일 스냅샷 중복 제거 (해시 기반)

## 결과 (Consequences)

### 장점
- **무결성 보장**: 해시 검증으로 데이터 손상 감지
- **단순성**: 불변이므로 동시성 문제 없음
- **공간 효율**: 중복 제거로 저장 공간 절약

### 단점
- **저장 공간**: 많은 체크포인트 생성 시 공간 증가
- **완화**: 보존 정책 (최근 N개 전체 + 이전 일별 대표)

## 대안 (Alternatives)

### 델타 기반 스냅샷
- **장점**: 저장 공간 효율
- **단점**: 복원 시 델타 재구성 복잡, 성능 저하
- **결정**: 단순성과 성능 우선

### Git 스타일 커밋
- **장점**: 개발자에게 익숙
- **단점**: 일반 사용자에게 어려움, 구현 복잡
- **결정**: 타겟 사용자에게 부적합

## 관련 결정

- ADR-007: 체크포인트 생성 시점

---

# ADR-007: 체크포인트 자동 생성 전략

- 날짜: 2025-11-05
- 상태: 승인
- 결정자: 아키텍처 설계자

## 맥락 (Context)

체크포인트를 언제 생성할지 결정해야 합니다. 너무 자주 생성하면 저장 공간 낭비, 너무 드물면 복원 정확도 저하.

## 결정 (Decision)

**다음 시점에 자동으로 체크포인트를 생성합니다.**
1. 대화 턴 쌍 완료 시 (사용자 → AI)
2. 분기 생성 직후
3. 경로 전환 직전과 직후
4. 병합 승인 직후 (2단계)
5. 중요한 설정 변경 직후

추가로 **사용자가 수동으로도 생성 가능**.

## 결과 (Consequences)

### 장점
- **세밀한 복원**: 중요한 시점을 놓치지 않음
- **자동화**: 사용자 개입 없이 안전망 제공
- **유연성**: 수동 생성도 가능

### 단점
- **저장 공간**: 체크포인트 증가
- **완화**: 보존 정책 적용, 중복 제거

## 대안 (Alternatives)

### 수동 생성만 허용
- **장점**: 저장 공간 최소화
- **단점**: 사용자가 잊어버릴 수 있음
- **결정**: 안전성 우선

### 모든 노드 생성 시 자동
- **장점**: 완벽한 복원
- **단점**: 저장 공간 과도 소비
- **결정**: 중요 시점만 선택

## 관련 결정

- ADR-006: 체크포인트 불변 스냅샷 방식

---

# ADR-008: MongoDB 인덱스 전략

- 날짜: 2025-11-05
- 상태: 승인
- 결정자: 아키텍처 설계자

## 맥락 (Context)

경로 조회(`findPathToRoot`)와 자식 조회(`findChildren`)가 빈번하게 발생합니다. 인덱스 최적화가 성능에 중요합니다.

## 결정 (Decision)

**다음 복합 인덱스를 생성합니다.**
```javascript
db.nodes.createIndex({ conversationId: 1, parentId: 1, depth: 1 })
db.nodes.createIndex({ conversationId: 1, createdAt: -1 })
db.checkpoints.createIndex({ conversationId: 1, createdAt: -1 })
db.shelves.createIndex({ conversationId: 1 })
```

## 결과 (Consequences)

### 장점
- **빠른 경로 조회**: parentId와 depth로 최적화
- **빠른 시간 정렬**: createdAt 인덱스
- **쿼리 효율**: 복합 인덱스로 여러 필드 동시 최적화

### 단점
- **쓰기 오버헤드**: 인덱스 유지 비용
- **저장 공간**: 인덱스 크기

## 관련 결정

- ADR-002: MongoDB 선택

---

# ADR-009: OpenAI API 선택 및 프로바이더 추상화

- 날짜: 2025-11-05
- 상태: 승인
- 결정자: 아키텍처 설계자

## 맥락 (Context)

AI 응답 생성을 위한 프로바이더가 필요합니다. 품질, 비용, 안정성, 확장성을 모두 고려해야 합니다.

## 결정 (Decision)

**OpenAI GPT-4를 기본 프로바이더로 사용하되, 프로바이더 추상화 레이어를 구축합니다.**
```python
class AIProvider(ABC):
    @abstractmethod
    async def generate(self, messages, max_tokens) -> str:
        pass

class OpenAIProvider(AIProvider):
    # OpenAI 구현

class AnthropicProvider(AIProvider):
    # Anthropic Claude 구현
```

## 결과 (Consequences)

### 장점
- **최고 품질**: GPT-4의 뛰어난 응답 품질
- **확장성**: 다른 프로바이더로 쉽게 전환
- **리스크 완화**: OpenAI 장애 시 대안 사용 가능
- **비용 최적화**: 상황에 따라 GPT-3.5 사용 가능

### 단점
- **비용**: GPT-4는 상대적으로 비쌈
- **완화**: GPT-3.5-turbo 혼용, 프롬프트 최적화

## 대안 (Alternatives)

### Anthropic Claude
- **장점**: 긴 컨텍스트(100k), 안전성 우수
- **단점**: OpenAI보다 생태계 작음
- **결정**: 대안 프로바이더로 준비

### 로컬 LLaMA
- **장점**: 비용 제로, 데이터 보안
- **단점**: 품질 낮음, 인프라 관리 부담
- **결정**: MVP에서 제외, 장기적으로 고려

## 관련 결정

- ADR-005: 활성 경로 기반 컨텍스트

---

# ADR-010: Vanilla JavaScript 프론트엔드 (MVP)

- 날짜: 2025-11-05
- 상태: 승인 (향후 React 전환 예정)
- 결정자: 아키텍처 설계자

## 맥락 (Context)

프론트엔드 구현 방식을 결정해야 합니다. 핵심 알고리즘(트리 구조, 경로 전환, LCA)을 먼저 검증하는 것이 중요합니다.

## 결정 (Decision)

**MVP는 Vanilla JavaScript로 구현합니다.**
- 프레임워크 없이 HTML/CSS/JS만 사용
- 커스텀 StateManager로 상태 관리
- 알고리즘 검증 후 React로 점진적 전환

## 결과 (Consequences)

### 장점
- **빠른 프로토타이핑**: 프레임워크 학습 시간 절약
- **명확한 로직**: 추상화 없이 알고리즘 직접 구현
- **마이그레이션 용이**: 알고리즘 검증 후 React 전환

### 단점
- **확장성**: 대규모 앱에 불리
- **재사용성**: 컴포넌트 재사용 제한
- **완화**: 알고리즘 검증 후 React 전환 계획

## 대안 (Alternatives)

### 처음부터 React
- **장점**: 컴포넌트 재사용, 생태계
- **단점**: 학습 곡선, 초기 설정 시간
- **결정**: 알고리즘 검증 우선

## 관련 결정

- 향후 ADR: React 전환 시점 및 방법

---

## 의사결정 요약표

| ADR | 결정 | 상태 | 주요 근거 |
|-----|------|------|----------|
| ADR-001 | 트리 구조 기반 대화 관리 | 승인 | 자유로운 탐색, 맥락 보존 |
| ADR-002 | MongoDB 선택 | 승인 | 스키마 유연성, 문서 지향 |
| ADR-003 | LCA 이중 전략 | 승인 | 초기 단순성 + 향후 성능 |
| ADR-004 | 단순 경로 교체 | 승인 | 예측 가능성, 구현 단순 |
| ADR-005 | 활성 경로 컨텍스트 | 승인 | 명확한 컨텍스트, 토큰 효율 |
| ADR-006 | 불변 스냅샷 | 승인 | 무결성 보장, 단순성 |
| ADR-007 | 자동 체크포인트 | 승인 | 세밀한 복원, 안전성 |
| ADR-008 | 인덱스 전략 | 승인 | 쿼리 성능 최적화 |
| ADR-009 | OpenAI + 추상화 | 승인 | 품질 + 확장성 |
| ADR-010 | Vanilla JS (MVP) | 승인 | 빠른 검증, 향후 전환 |

## 향후 ADR 예정

- **ADR-011**: Redis 캐시 전략 상세
- **ADR-012**: React 전환 시점 및 방법
- **ADR-013**: Binary Lifting 전환 임계값 조정
- **ADR-014**: 병합(Merge) 기능 설계 (2단계)
- **ADR-015**: WebSocket 실시간 알림 (2단계)
- **ADR-016**: Kubernetes 배포 전략 (3단계)

---

## 문서 관리

### 변경 이력
- 2025-11-05: 초안 작성 (ADR-001~010)

### 검토 주기
- 월 1회 정기 검토
- 주요 기술 변경 시 즉시 검토

### 상태 전환
- **제안**: 초안 작성
- **승인**: 팀 합의 후 확정
- **폐기**: 더 나은 대안으로 대체
- **대체**: 새로운 ADR로 교체 (기존 문서 보존)
