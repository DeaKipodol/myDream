# 백엔드 개발자 지시서
- 작성일: 2025-11-05
- 설계자: 아키텍처 설계자
- 대상: 백엔드 개발자
- 기술 스택: Python 3.10+ / FastAPI / MongoDB / Redis
- 상태: 승인
- 버전: 1.0

## 1. 프로젝트 개요

트리 구조 기반 AI 대화 시스템의 백엔드를 개발합니다. 핵심 기능은 경로 전환(Path Switch), LCA 계산, 체크포인트 관리, AI 응답 생성입니다.

### 핵심 기능
- 대화 및 노드 CRUD
- 경로 전환 (LCA 기반)
- 체크포인트 생성/복원
- 보존 영역 관리
- AI 응답 생성

### 성능 목표
- 경로 전환 API: p95 200ms
- 체크포인트 복원: p95 300ms
- 캐시 적중률: 80%

## 2. 파일 구조

```
backend/
├── main.py                  # FastAPI 진입점 (100줄)
├── config/
│   ├── __init__.py
│   ├── settings.py          # 환경 설정 (150줄)
│   └── database.py          # DB 연결 (100줄)
├── api/
│   ├── __init__.py
│   ├── dependencies.py      # 의존성 주입 (100줄)
│   └── v1/
│       ├── __init__.py
│       ├── conversations.py # 대화 API (300줄)
│       ├── paths.py         # 경로 API (250줄)
│       ├── checkpoints.py   # 체크포인트 API (200줄)
│       └── ai.py            # AI API (200줄)
├── domain/
│   ├── __init__.py
│   ├── models/
│   │   ├── __init__.py
│   │   ├── conversation.py  # 대화 모델 (150줄)
│   │   ├── node.py          # 노드 모델 (150줄)
│   │   ├── checkpoint.py    # 체크포인트 모델 (100줄)
│   │   └── shelf.py         # 보존 영역 모델 (80줄)
│   ├── services/
│   │   ├── __init__.py
│   │   ├── conversation_service.py     # 대화 서비스 (300줄)
│   │   ├── path_switch_service.py      # 경로 전환 (400줄)
│   │   ├── lca_service.py              # LCA 계산 (300줄)
│   │   ├── checkpoint_service.py       # 체크포인트 (250줄)
│   │   ├── snapshot_service.py         # 스냅샷 (200줄)
│   │   ├── shelf_service.py            # 보존 영역 (150줄)
│   │   ├── ai_service.py               # AI 통합 (300줄)
│   │   └── context_builder.py          # 컨텍스트 구성 (200줄)
│   └── algorithms/
│       ├── __init__.py
│       ├── lca_linear.py    # 선형 LCA (150줄)
│       └── lca_binary_lifting.py # Binary Lifting (250줄)
├── infrastructure/
│   ├── __init__.py
│   ├── repositories/
│   │   ├── __init__.py
│   │   ├── conversation_repository.py  # 대화 레포 (250줄)
│   │   ├── node_repository.py          # 노드 레포 (300줄)
│   │   ├── checkpoint_repository.py    # 체크포인트 레포 (200줄)
│   │   └── shelf_repository.py         # 보존 영역 레포 (150줄)
│   ├── cache/
│   │   ├── __init__.py
│   │   ├── redis_cache.py   # Redis 캐시 (200줄)
│   │   └── memory_cache.py  # 인메모리 캐시 (150줄)
│   └── ai_providers/
│       ├── __init__.py
│       ├── base.py          # AI 프로바이더 인터페이스 (100줄)
│       ├── openai_provider.py # OpenAI 구현 (250줄)
│       └── anthropic_provider.py # Anthropic 구현 (250줄)
├── shared/
│   ├── __init__.py
│   ├── schemas/
│   │   ├── __init__.py
│   │   ├── conversation.py  # 요청/응답 스키마 (200줄)
│   │   ├── path.py          # 경로 스키마 (150줄)
│   │   └── checkpoint.py    # 체크포인트 스키마 (100줄)
│   ├── exceptions.py        # 커스텀 예외 (150줄)
│   ├── constants.py         # 상수 (100줄)
│   └── utils/
│       ├── __init__.py
│       ├── hashing.py       # 해시 유틸 (80줄)
│       └── validators.py    # 검증 유틸 (100줄)
└── tests/
    ├── unit/
    │   ├── test_lca_service.py
    │   ├── test_path_switch.py
    │   └── test_checkpoint_service.py
    ├── integration/
    │   ├── test_api_conversations.py
    │   └── test_api_paths.py
    └── e2e/
        └── test_full_flow.py
```

## 3. 파일별 구현 가이드

### 3.1 main.py (FastAPI 진입점)

#### 목적
FastAPI 앱 초기화, 라우터 등록, 미들웨어 설정

#### 크기 제한
최대 100줄

#### 구현 요구사항

```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from api.v1 import conversations, paths, checkpoints, ai
from config.database import connect_db, close_db

app = FastAPI(
    title="AI Consultation API",
    version="1.0.0",
    description="트리 구조 기반 AI 고민상담 시스템"
)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 라이프사이클 이벤트
@app.on_event("startup")
async def startup():
    await connect_db()

@app.on_event("shutdown")
async def shutdown():
    await close_db()

# 라우터 등록
app.include_router(
    conversations.router,
    prefix="/api/v1/conversations",
    tags=["conversations"]
)
app.include_router(
    paths.router,
    prefix="/api/v1",
    tags=["paths"]
)
app.include_router(
    checkpoints.router,
    prefix="/api/v1",
    tags=["checkpoints"]
)
app.include_router(
    ai.router,
    prefix="/api/v1/ai",
    tags=["ai"]
)

# 헬스체크
@app.get("/healthz")
async def health_check():
    return {"status": "ok"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

#### 체크리스트
- [ ] FastAPI 앱 생성
- [ ] CORS 설정
- [ ] 라우터 등록
- [ ] 헬스체크 엔드포인트
- [ ] 라이프사이클 이벤트

---

### 3.2 config/settings.py (환경 설정)

#### 목적
환경 변수 로드, 설정 관리

#### 크기 제한
최대 150줄

#### 구현 요구사항

```python
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    # MongoDB
    MONGO_URL: str = "mongodb://localhost:27017"
    MONGO_DB_NAME: str = "ai_consultation"

    # Redis
    REDIS_URL: str = "redis://localhost:6379"
    REDIS_TTL: int = 900  # 15분

    # OpenAI
    OPENAI_API_KEY: str
    OPENAI_MODEL: str = "gpt-4"
    OPENAI_MAX_TOKENS: int = 2000

    # LCA
    LCA_THRESHOLD: int = 1000  # 노드 수 임계값

    # 캐시
    CACHE_ENABLED: bool = True
    CACHE_TARGET_HIT_RATE: float = 0.8

    # 체크포인트
    CHECKPOINT_RETENTION_DAYS: int = 180

    class Config:
        env_file = ".env"
        case_sensitive = True

settings = Settings()
```

#### 체크리스트
- [ ] pydantic_settings 사용
- [ ] 환경 변수 정의
- [ ] 기본값 설정
- [ ] .env 파일 지원

---

### 3.3 config/database.py (DB 연결)

#### 목적
MongoDB 연결 관리

#### 크기 제한
최대 100줄

#### 구현 요구사항

```python
from motor.motor_asyncio import AsyncIOMotorClient
from config.settings import settings

class Database:
    client: AsyncIOMotorClient = None
    db = None

db = Database()

async def connect_db():
    """MongoDB 연결"""
    db.client = AsyncIOMotorClient(settings.MONGO_URL)
    db.db = db.client[settings.MONGO_DB_NAME]
    print("MongoDB 연결 성공")

async def close_db():
    """MongoDB 연결 종료"""
    if db.client:
        db.client.close()
        print("MongoDB 연결 종료")

def get_db():
    """DB 인스턴스 반환"""
    return db.db
```

#### 체크리스트
- [ ] Motor 비동기 클라이언트 사용
- [ ] 연결/종료 함수 구현
- [ ] 싱글톤 패턴

---

### 3.4 api/v1/conversations.py (대화 API)

#### 목적
대화 CRUD 엔드포인트

#### 크기 제한
최대 300줄

#### 구현 요구사항

```python
from fastapi import APIRouter, Depends, HTTPException, status
from typing import List
from domain.services.conversation_service import ConversationService
from shared.schemas.conversation import (
    ConversationCreate,
    ConversationResponse,
    NodeCreate,
    NodeResponse
)
from api.dependencies import get_conversation_service

router = APIRouter()

@router.post("/", response_model=ConversationResponse, status_code=status.HTTP_201_CREATED)
async def create_conversation(
    data: ConversationCreate,
    service: ConversationService = Depends(get_conversation_service)
):
    """새 대화 생성"""
    try:
        conversation = await service.create(data)
        return conversation
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/{conversation_id}", response_model=ConversationResponse)
async def get_conversation(
    conversation_id: str,
    service: ConversationService = Depends(get_conversation_service)
):
    """대화 조회"""
    conversation = await service.get_by_id(conversation_id)
    if not conversation:
        raise HTTPException(status_code=404, detail="대화를 찾을 수 없습니다")
    return conversation

@router.get("/", response_model=List[ConversationResponse])
async def list_conversations(
    skip: int = 0,
    limit: int = 10,
    service: ConversationService = Depends(get_conversation_service)
):
    """대화 목록 조회"""
    conversations = await service.list(skip=skip, limit=limit)
    return conversations

@router.post("/{conversation_id}/nodes", response_model=NodeResponse, status_code=status.HTTP_201_CREATED)
async def create_node(
    conversation_id: str,
    data: NodeCreate,
    service: ConversationService = Depends(get_conversation_service)
):
    """노드 생성"""
    try:
        node = await service.create_node(conversation_id, data)
        return node
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/{conversation_id}/nodes", response_model=List[NodeResponse])
async def list_nodes(
    conversation_id: str,
    service: ConversationService = Depends(get_conversation_service)
):
    """대화의 모든 노드 조회"""
    nodes = await service.list_nodes(conversation_id)
    return nodes

@router.get("/{conversation_id}/nodes/{node_id}/path", response_model=List[str])
async def get_node_path(
    conversation_id: str,
    node_id: str,
    service: ConversationService = Depends(get_conversation_service)
):
    """노드의 루트까지 경로 조회"""
    try:
        path = await service.get_path_to_root(conversation_id, node_id)
        return path
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
```

#### 체크리스트
- [ ] 대화 생성/조회/목록
- [ ] 노드 생성/목록
- [ ] 경로 조회
- [ ] 의존성 주입
- [ ] 에러 핸들링
- [ ] OpenAPI 문서화

---

### 3.5 api/v1/paths.py (경로 API)

#### 목적
경로 전환 엔드포인트

#### 크기 제한
최대 250줄

#### 구현 요구사항

```python
from fastapi import APIRouter, Depends, HTTPException
from domain.services.path_switch_service import PathSwitchService
from shared.schemas.path import PathSwitchRequest, PathSwitchResponse
from api.dependencies import get_path_switch_service

router = APIRouter()

@router.post("/conversations/{conversation_id}/switch", response_model=PathSwitchResponse)
async def switch_path(
    conversation_id: str,
    data: PathSwitchRequest,
    service: PathSwitchService = Depends(get_path_switch_service)
):
    """경로 전환"""
    try:
        result = await service.switch(
            conversation_id,
            data.currentLeafId,
            data.targetNodeId
        )
        return result
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except HTTPException as e:
        raise e
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

#### 체크리스트
- [ ] 경로 전환 엔드포인트
- [ ] 에러 핸들링 (400, 409, 500)
- [ ] Pydantic 스키마 검증

---

### 3.6 domain/services/path_switch_service.py (경로 전환 서비스)

#### 목적
경로 전환 비즈니스 로직

#### 크기 제한
최대 400줄

#### 구현 요구사항

```python
from typing import Dict, List
from domain.services.lca_service import LCAService
from domain.services.checkpoint_service import CheckpointService
from domain.services.shelf_service import ShelfService
from infrastructure.repositories.node_repository import NodeRepository
from infrastructure.repositories.conversation_repository import ConversationRepository

class PathSwitchService:
    def __init__(
        self,
        lca_service: LCAService,
        checkpoint_service: CheckpointService,
        shelf_service: ShelfService,
        node_repo: NodeRepository,
        conversation_repo: ConversationRepository
    ):
        self.lca_service = lca_service
        self.checkpoint_service = checkpoint_service
        self.shelf_service = shelf_service
        self.node_repo = node_repo
        self.conversation_repo = conversation_repo

    async def switch(
        self,
        conversation_id: str,
        current_leaf_id: str,
        target_node_id: str
    ) -> Dict:
        """
        경로 전환 메인 로직

        1. LCA 계산
        2. 경로 재구성
        3. 전환 전 체크포인트
        4. 보존 영역 이동
        5. 활성 경로 교체
        6. 전환 후 체크포인트

        Args:
            conversation_id: 대화 ID
            current_leaf_id: 현재 리프 노드 ID
            target_node_id: 목표 노드 ID

        Returns:
            {
                "activePathIds": ["A", "B", "F"],
                "lcaNodeId": "B",
                "checkpointBeforeId": "ckpt-001",
                "checkpointAfterId": "ckpt-002"
            }

        Raises:
            ValueError: 노드가 존재하지 않거나 유효하지 않음
        """
        # 1. 노드 존재 검증
        current_leaf = await self.node_repo.find_by_id(current_leaf_id)
        target_node = await self.node_repo.find_by_id(target_node_id)

        if not current_leaf or not target_node:
            raise ValueError("노드를 찾을 수 없습니다")

        # 동일 노드 클릭 시 no-op
        if current_leaf_id == target_node_id:
            conversation = await self.conversation_repo.find_by_id(conversation_id)
            return {
                "activePathIds": conversation.get("activePathIds", []),
                "lcaNodeId": target_node_id,
                "checkpointBeforeId": None,
                "checkpointAfterId": None
            }

        # 2. LCA 계산
        lca_id = await self.lca_service.calculate(
            conversation_id,
            current_leaf_id,
            target_node_id
        )

        # 3. 경로 재구성
        prefix = await self.node_repo.find_path_to_root(lca_id)
        suffix = await self.node_repo.find_path_from_to(lca_id, target_node_id)

        # LCA 중복 제거
        new_active_path = prefix + suffix[1:] if len(suffix) > 1 else prefix

        # 4. 전환 전 체크포인트
        conversation = await self.conversation_repo.find_by_id(conversation_id)
        old_active_path = conversation.get("activePathIds", [])

        before_checkpoint = await self.checkpoint_service.create(
            conversation_id,
            active_path_ids=old_active_path,
            reason="before_switch"
        )

        # 5. 보존 영역 이동
        # LCA 이후 분기 식별
        lca_index = old_active_path.index(lca_id) if lca_id in old_active_path else -1
        if lca_index >= 0 and lca_index + 1 < len(old_active_path):
            old_branch = old_active_path[lca_index + 1:]
            await self.shelf_service.mark_hidden(
                conversation_id,
                hidden_path_ids=old_branch,
                from_checkpoint_id=before_checkpoint["id"]
            )

        # 6. 활성 경로 교체
        await self.conversation_repo.update(
            conversation_id,
            {"activePathIds": new_active_path}
        )

        # 7. 전환 후 체크포인트
        after_checkpoint = await self.checkpoint_service.create(
            conversation_id,
            active_path_ids=new_active_path,
            reason="after_switch"
        )

        return {
            "activePathIds": new_active_path,
            "lcaNodeId": lca_id,
            "checkpointBeforeId": before_checkpoint["id"],
            "checkpointAfterId": after_checkpoint["id"]
        }
```

#### 체크리스트
- [ ] LCA 계산 호출
- [ ] 경로 재구성 (prefix + suffix)
- [ ] 전/후 체크포인트 생성
- [ ] 보존 영역 마킹
- [ ] 활성 경로 교체
- [ ] 에러 핸들링
- [ ] 타입 힌트 및 Docstring

---

### 3.7 domain/services/lca_service.py (LCA 서비스)

#### 목적
LCA 계산 조율, 선형 vs Binary Lifting 전략 선택

#### 크기 제한
최대 300줄

#### 구현 요구사항

```python
from infrastructure.repositories.node_repository import NodeRepository
from infrastructure.cache.redis_cache import RedisCache
from domain.algorithms.lca_linear import calculate_lca_linear
from domain.algorithms.lca_binary_lifting import calculate_lca_binary_lifting
from config.settings import settings

class LCAService:
    def __init__(
        self,
        node_repo: NodeRepository,
        cache: RedisCache,
        threshold: int = None
    ):
        self.node_repo = node_repo
        self.cache = cache
        self.threshold = threshold or settings.LCA_THRESHOLD

    async def calculate(
        self,
        conversation_id: str,
        node_a_id: str,
        node_b_id: str
    ) -> str:
        """
        LCA 계산

        Args:
            conversation_id: 대화 ID
            node_a_id: 노드 A ID
            node_b_id: 노드 B ID

        Returns:
            LCA 노드 ID
        """
        # 1. 캐시 확인
        cache_key = self._get_cache_key(node_a_id, node_b_id)
        cached = await self.cache.get(cache_key)
        if cached:
            return cached

        # 2. 노드 수 확인
        node_count = await self.node_repo.count_by_conversation(conversation_id)

        # 3. 알고리즘 선택
        if node_count < self.threshold:
            lca = await calculate_lca_linear(node_a_id, node_b_id, self.node_repo)
        else:
            lca = await calculate_lca_binary_lifting(node_a_id, node_b_id, self.node_repo)

        # 4. 캐시 저장
        await self.cache.set(cache_key, lca, ttl=settings.REDIS_TTL)

        return lca

    def _get_cache_key(self, node_a_id: str, node_b_id: str) -> str:
        """캐시 키 생성 (정렬하여 일관성 보장)"""
        sorted_ids = sorted([node_a_id, node_b_id])
        return f"lca:{sorted_ids[0]}:{sorted_ids[1]}"
```

#### 체크리스트
- [ ] 캐시 조회
- [ ] 노드 수 확인
- [ ] 알고리즘 전략 선택
- [ ] 캐시 저장
- [ ] 타입 힌트

---

### 3.8 domain/algorithms/lca_linear.py (선형 LCA)

#### 목적
선형 LCA 알고리즘 구현

#### 크기 제한
최대 150줄

#### 구현 요구사항

```python
from infrastructure.repositories.node_repository import NodeRepository

async def calculate_lca_linear(
    node_a_id: str,
    node_b_id: str,
    node_repo: NodeRepository
) -> str:
    """
    선형 LCA 계산

    시간 복잡도: O(h) where h = tree height

    알고리즘:
    1. 두 노드의 깊이를 맞춤
    2. 동시에 부모로 상승하여 공통 조상 찾기

    Args:
        node_a_id: 노드 A ID
        node_b_id: 노드 B ID
        node_repo: 노드 리포지토리

    Returns:
        LCA 노드 ID
    """
    # 1. 두 노드 조회
    node_a = await node_repo.find_by_id(node_a_id)
    node_b = await node_repo.find_by_id(node_b_id)

    if not node_a or not node_b:
        raise ValueError("노드를 찾을 수 없습니다")

    # 2. 깊이 맞추기
    while node_a["depth"] > node_b["depth"]:
        node_a = await node_repo.find_by_id(node_a["parentId"])

    while node_b["depth"] > node_a["depth"]:
        node_b = await node_repo.find_by_id(node_b["parentId"])

    # 3. 동시 상승하여 공통 조상 찾기
    while node_a["id"] != node_b["id"]:
        node_a = await node_repo.find_by_id(node_a["parentId"])
        node_b = await node_repo.find_by_id(node_b["parentId"])

        # 무한 루프 방지 (루트에 도달)
        if not node_a or not node_b:
            raise ValueError("LCA를 찾을 수 없습니다")

    return node_a["id"]
```

#### 체크리스트
- [ ] 깊이 맞추기
- [ ] 동시 상승
- [ ] 에러 핸들링
- [ ] Docstring

---

### 3.9 infrastructure/repositories/node_repository.py (노드 레포)

#### 목적
노드 데이터 CRUD

#### 크기 제한
최대 300줄

#### 구현 요구사항

```python
from typing import List, Dict, Optional
from motor.motor_asyncio import AsyncIOMotorDatabase
from domain.models.node import Node

class NodeRepository:
    def __init__(self, db: AsyncIOMotorDatabase):
        self.collection = db["nodes"]

    async def create(self, node: Node) -> Dict:
        """노드 생성"""
        result = await self.collection.insert_one(node.dict())
        node_dict = node.dict()
        node_dict["_id"] = str(result.inserted_id)
        return node_dict

    async def find_by_id(self, node_id: str) -> Optional[Dict]:
        """노드 조회"""
        node = await self.collection.find_one({"id": node_id})
        return node

    async def find_by_conversation_id(self, conversation_id: str) -> List[Dict]:
        """대화의 모든 노드 조회"""
        cursor = self.collection.find({"conversationId": conversation_id})
        nodes = await cursor.to_list(length=1000)
        return nodes

    async def count_by_conversation(self, conversation_id: str) -> int:
        """대화의 노드 수"""
        count = await self.collection.count_documents({"conversationId": conversation_id})
        return count

    async def find_path_to_root(self, node_id: str) -> List[str]:
        """
        노드에서 루트까지 경로 조회

        Returns:
            ["root", "parent", "node"]
        """
        path = []
        current_id = node_id

        while current_id:
            node = await self.find_by_id(current_id)
            if not node:
                break
            path.insert(0, node["id"])
            current_id = node.get("parentId")

        return path

    async def find_path_from_to(self, from_node_id: str, to_node_id: str) -> List[str]:
        """
        from_node에서 to_node까지 경로 조회

        Returns:
            ["from", "...", "to"]
        """
        # to_node에서 루트까지 경로 조회
        full_path = await self.find_path_to_root(to_node_id)

        # from_node 인덱스 찾기
        if from_node_id in full_path:
            from_index = full_path.index(from_node_id)
            return full_path[from_index:]
        else:
            raise ValueError(f"{from_node_id}는 {to_node_id}의 조상이 아닙니다")

    async def find_children(self, parent_id: str) -> List[Dict]:
        """자식 노드 조회"""
        cursor = self.collection.find({"parentId": parent_id})
        children = await cursor.to_list(length=100)
        return children
```

#### 체크리스트
- [ ] CRUD 연산
- [ ] 경로 조회 메서드
- [ ] 자식 조회
- [ ] 타입 힌트
- [ ] Docstring

---

### 3.10 infrastructure/cache/redis_cache.py (Redis 캐시)

#### 목적
Redis 캐시 추상화

#### 크기 제한
최대 200줄

#### 구현 요구사항

```python
from typing import Optional
import redis.asyncio as aioredis
import json
from config.settings import settings

class RedisCache:
    def __init__(self):
        self.redis: Optional[aioredis.Redis] = None

    async def connect(self):
        """Redis 연결"""
        self.redis = await aioredis.from_url(settings.REDIS_URL)

    async def disconnect(self):
        """Redis 연결 종료"""
        if self.redis:
            await self.redis.close()

    async def get(self, key: str) -> Optional[str]:
        """캐시 조회"""
        if not self.redis:
            return None
        value = await self.redis.get(key)
        return value.decode() if value else None

    async def set(self, key: str, value: str, ttl: int = None):
        """캐시 저장"""
        if not self.redis:
            return
        if ttl:
            await self.redis.setex(key, ttl, value)
        else:
            await self.redis.set(key, value)

    async def delete(self, key: str):
        """캐시 삭제"""
        if not self.redis:
            return
        await self.redis.delete(key)

    async def get_json(self, key: str) -> Optional[dict]:
        """JSON 캐시 조회"""
        value = await self.get(key)
        return json.loads(value) if value else None

    async def set_json(self, key: str, value: dict, ttl: int = None):
        """JSON 캐시 저장"""
        json_str = json.dumps(value)
        await self.set(key, json_str, ttl)
```

#### 체크리스트
- [ ] Redis 비동기 클라이언트
- [ ] get/set/delete 메서드
- [ ] JSON 직렬화/역직렬화
- [ ] TTL 지원

---

### 3.11 infrastructure/ai_providers/openai_provider.py (OpenAI)

#### 목적
OpenAI API 통합

#### 크기 제한
최대 250줄

#### 구현 요구사항

```python
from typing import List, Dict
import openai
from infrastructure.ai_providers.base import AIProvider
from config.settings import settings

class OpenAIProvider(AIProvider):
    def __init__(self):
        openai.api_key = settings.OPENAI_API_KEY

    async def generate(
        self,
        messages: List[Dict[str, str]],
        max_tokens: int = None
    ) -> str:
        """
        AI 응답 생성

        Args:
            messages: 메시지 목록 [{"role": "user", "content": "..."}]
            max_tokens: 최대 토큰 수

        Returns:
            AI 응답 내용
        """
        try:
            response = await openai.ChatCompletion.acreate(
                model=settings.OPENAI_MODEL,
                messages=messages,
                max_tokens=max_tokens or settings.OPENAI_MAX_TOKENS,
                temperature=0.7
            )

            content = response.choices[0].message.content
            return content

        except openai.error.RateLimitError as e:
            raise Exception(f"Rate limit 초과: {e}")
        except openai.error.APIError as e:
            raise Exception(f"OpenAI API 오류: {e}")
        except Exception as e:
            raise Exception(f"AI 응답 생성 실패: {e}")
```

#### 체크리스트
- [ ] OpenAI SDK 사용
- [ ] 비동기 호출
- [ ] 에러 핸들링
- [ ] 프로바이더 인터페이스 구현

---

### 3.12 shared/schemas/conversation.py (스키마)

#### 목적
Pydantic 요청/응답 스키마

#### 크기 제한
최대 200줄

#### 구현 요구사항

```python
from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime

class ConversationCreate(BaseModel):
    title: str = Field(..., min_length=1, max_length=200)
    domain: Optional[str] = Field(None, max_length=50)

class ConversationResponse(BaseModel):
    id: str
    ownerId: Optional[str]
    title: str
    rootId: Optional[str]
    activePathIds: List[str] = []
    createdAt: datetime
    updatedAt: datetime

    class Config:
        from_attributes = True

class NodeCreate(BaseModel):
    parentId: Optional[str]
    role: str = Field(..., pattern="^(user|assistant|system)$")
    content: str = Field(..., min_length=1)

class NodeResponse(BaseModel):
    id: str
    conversationId: str
    parentId: Optional[str]
    role: str
    content: str
    depth: int
    createdAt: datetime

    class Config:
        from_attributes = True
```

#### 체크리스트
- [ ] 요청/응답 스키마 분리
- [ ] Pydantic 검증 (Field)
- [ ] Config.from_attributes
- [ ] 타입 힌트

---

## 4. 데이터베이스 인덱스 생성

### MongoDB 인덱스

```python
# scripts/create_indexes.py
from motor.motor_asyncio import AsyncIOMotorClient

async def create_indexes():
    client = AsyncIOMotorClient("mongodb://localhost:27017")
    db = client["ai_consultation"]

    # nodes 인덱스
    await db.nodes.create_index([
        ("conversationId", 1),
        ("parentId", 1),
        ("depth", 1)
    ])
    await db.nodes.create_index([
        ("conversationId", 1),
        ("createdAt", -1)
    ])

    # checkpoints 인덱스
    await db.checkpoints.create_index([
        ("conversationId", 1),
        ("createdAt", -1)
    ])

    # shelves 인덱스
    await db.shelves.create_index([("conversationId", 1)])

    print("인덱스 생성 완료")

if __name__ == "__main__":
    import asyncio
    asyncio.run(create_indexes())
```

---

## 5. 의존성 주입

### api/dependencies.py

```python
from fastapi import Depends
from config.database import get_db
from infrastructure.repositories.node_repository import NodeRepository
from infrastructure.repositories.conversation_repository import ConversationRepository
from infrastructure.cache.redis_cache import RedisCache
from domain.services.lca_service import LCAService
from domain.services.path_switch_service import PathSwitchService
# ...

# 싱글톤 캐시
_redis_cache = None

async def get_redis_cache() -> RedisCache:
    global _redis_cache
    if not _redis_cache:
        _redis_cache = RedisCache()
        await _redis_cache.connect()
    return _redis_cache

async def get_node_repository(db=Depends(get_db)) -> NodeRepository:
    return NodeRepository(db)

async def get_lca_service(
    node_repo: NodeRepository = Depends(get_node_repository),
    cache: RedisCache = Depends(get_redis_cache)
) -> LCAService:
    return LCAService(node_repo, cache)

async def get_path_switch_service(
    lca_service: LCAService = Depends(get_lca_service),
    # ...
) -> PathSwitchService:
    return PathSwitchService(lca_service, ...)
```

---

## 6. 테스트

### unit/test_lca_service.py

```python
import pytest
from domain.services.lca_service import LCAService

@pytest.mark.asyncio
async def test_lca_linear():
    # given
    node_a_id = "D"
    node_b_id = "F"

    # when
    lca = await lca_service.calculate("conv-001", node_a_id, node_b_id)

    # then
    assert lca == "B"
```

---

## 7. 개발 체크리스트

### 환경 설정
- [ ] Python 3.10+ 설치
- [ ] MongoDB 설치 및 실행
- [ ] Redis 설치 및 실행
- [ ] .env 파일 생성

### 핵심 파일
- [ ] main.py: FastAPI 초기화
- [ ] config/settings.py: 환경 설정
- [ ] config/database.py: DB 연결

### 도메인 서비스
- [ ] path_switch_service.py: 경로 전환
- [ ] lca_service.py: LCA 계산
- [ ] checkpoint_service.py: 체크포인트

### 알고리즘
- [ ] lca_linear.py: 선형 LCA
- [ ] lca_binary_lifting.py: Binary Lifting (3단계)

### 리포지토리
- [ ] node_repository.py: 노드 CRUD
- [ ] conversation_repository.py: 대화 CRUD
- [ ] checkpoint_repository.py: 체크포인트 CRUD

### 인프라
- [ ] redis_cache.py: Redis 캐시
- [ ] openai_provider.py: OpenAI 통합

### API
- [ ] conversations.py: 대화 API
- [ ] paths.py: 경로 API
- [ ] checkpoints.py: 체크포인트 API
- [ ] ai.py: AI API

### 테스트
- [ ] 단위 테스트 작성
- [ ] 통합 테스트 작성
- [ ] E2E 테스트 작성

---

## 8. 개발 시 주의사항

### 파일 크기
- 각 파일은 **최대 1,000줄, 이상적 200줄**
- 초과 시 파일 분리

### 코드 스타일
- Black 포매터 사용
- Ruff 린터 사용
- 타입 힌트 필수
- Docstring 작성 (Google 스타일)

### 성능
- 비동기 I/O (asyncio)
- 캐시 적극 활용
- 인덱스 최적화
- N+1 쿼리 방지

### 보안
- 환경 변수로 시크릿 관리
- SQL/NoSQL 인젝션 방지
- 입력 검증 (Pydantic)
- Rate limiting

---

## 9. 다음 단계

1. **환경 구축**: Python, MongoDB, Redis 설치
2. **핵심 구현**: settings, database, main.py
3. **서비스 구현**: PathSwitchService, LCAService
4. **API 구현**: conversations, paths 엔드포인트
5. **통합 테스트**: 프론트엔드와 연동

**개발 완료 후 코드 리뷰를 진행합니다.**
