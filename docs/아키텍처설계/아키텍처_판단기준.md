# 아키텍처 판단 기준
- 작성일: 2025-11-05
- 작성자: 아키텍처 설계자
- 목적: PM 요청사항 검토 시 일관된 판단 기준 제시

## 1. 핵심 판단 기준 (우선순위)

### 1순위: 단순성 (Simplicity First)
**원칙**: "지금 필요한 것만 구현한다"

**판단 방법**:
- ✅ 현재 문제를 해결하는가?
- ✅ 코드가 이해하기 쉬운가?
- ❌ 미래를 위한 "혹시 모를" 기능인가?

**근거**:
- 복잡한 시스템은 유지보수 비용이 기하급수적으로 증가
- 프로토타입 단계에서는 빠른 검증이 최우선
- 필요할 때 점진적으로 추가하는 것이 안전

**예시**:
- ✅ 좋음: "LCA 계산은 선형 방식만 구현"
- ❌ 나쁨: "Binary Lifting도 미리 구현해두자" (지금 필요 없음)

---

### 2순위: 테스트 가능성 (Testability)
**원칙**: "검증할 수 없으면 신뢰할 수 없다"

**판단 방법**:
- ✅ 단위 테스트 작성이 쉬운가?
- ✅ 각 함수의 입출력이 명확한가?
- ✅ 부작용(side effect)이 격리되어 있는가?

**근거**:
- 핵심 알고리즘의 정확성 검증이 프로젝트 목표
- 버그는 초기에 발견할수록 수정 비용이 낮음
- 테스트 코드는 살아있는 문서 역할

**예시**:
- ✅ 좋음: `LCACalculator.calculate(tree, 'A', 'B')` → 순수 함수
- ❌ 나쁨: 전역 상태를 직접 변경하는 함수

---

### 3순위: 명확한 책임 분리 (Clear Separation of Concerns)
**원칙**: "각 클래스는 하나의 명확한 역할만 담당한다"

**판단 방법**:
- ✅ 클래스 이름만 봐도 역할이 명확한가?
- ✅ 한 클래스의 변경이 다른 클래스에 영향을 주지 않는가?
- ❌ "God Class" (모든 것을 하는 클래스)인가?

**근거**:
- 책임이 명확해야 코드 수정 시 영향 범위를 예측 가능
- 협업 시 각자 담당 영역이 명확
- 나중에 기능 추가/수정이 쉬움

**예시**:
- ✅ 좋음: `LCACalculator`는 LCA 계산만, `PathReconstructor`는 경로 재구성만
- ❌ 나쁨: `TreeManager`가 트리 관리 + 경로 계산 + UI 출력 모두 담당

---

### 4순위: 확장 가능성 (Extensibility)
**원칙**: "나중에 추가할 여지는 남겨둔다 (단, 미리 구현하지는 않음)"

**판단 방법**:
- ✅ 인터페이스가 명확한가?
- ✅ 새로운 기능 추가 시 기존 코드 수정이 최소화되는가?
- ❌ 확장을 위해 지금 복잡도가 증가하는가?

**근거**:
- 프로토타입 → 웹 전환 시 알고리즘 재사용 필요
- 하지만 "확장 가능성"을 명목으로 과설계는 금물

**예시**:
- ✅ 좋음: `LCAStrategy` 인터페이스 정의 (단, LinearLCA만 구현)
- ❌ 나쁨: Binary Lifting, Euler Tour, RMQ 모두 미리 구현

---

### 5순위: 성능 (Performance)
**원칙**: "충분히 빠르면 된다, 최적화는 필요할 때"

**판단 방법**:
- ✅ 프로토타입 규모(수십 개 노드)에서 충분히 빠른가?
- ❌ 프리미티브 최적화(premature optimization)인가?

**근거**:
- "Premature optimization is the root of all evil" - Donald Knuth
- 프로토타입 단계에서는 정확성 > 성능
- 병목이 실제로 발생할 때 측정하고 최적화

**예시**:
- ✅ 좋음: 선형 LCA (O(h)) → 수십 개 노드에서는 충분히 빠름
- ❌ 나쁨: Binary Lifting (O(log N)) → 지금은 오버엔지니어링

---

## 2. 판단 프레임워크

### 2.1 요청사항 검토 프로세스

```
PM 요청 접수
    ↓
[1단계] 필요성 검토
    - 지금 당장 필요한가?
    - 프로토타입 목표 달성에 필수인가?
    → NO → "나중에 추가하는 것을 권장" + 근거 제시
    → YES → 2단계로

[2단계] 복잡도 검토
    - 구현 복잡도가 높은가?
    - 기존 코드를 크게 수정해야 하는가?
    → YES → 단순한 대안 제시
    → NO → 3단계로

[3단계] 테스트 가능성 검토
    - 테스트 작성이 쉬운가?
    - 부작용이 격리되는가?
    → NO → 설계 수정 제안
    → YES → 승인

[4단계] 최종 결정
    - 판단 기준 명시
    - 대안이 있다면 함께 제시
    - 트레이드오프 설명
```

### 2.2 의사결정 매트릭스

| 판단 기준 | 가중치 | 평가 방법 |
|----------|--------|----------|
| 단순성 | 30% | 코드 라인 수, 클래스 수, 의존성 수 |
| 테스트 가능성 | 25% | 단위 테스트 작성 용이성 |
| 책임 분리 | 20% | 클래스당 책임 개수 |
| 확장성 | 15% | 향후 변경 시 영향 범위 |
| 성능 | 10% | 프로토타입 규모에서의 실행 시간 |

**점수 기준**:
- 80점 이상: 즉시 승인
- 60-79점: 조건부 승인 (개선 권고)
- 40-59점: 재검토 필요 (대안 제시)
- 40점 미만: 거부 (근거와 대안 제시)

---

## 3. 구체적 판단 사례

### 사례 1: "Binary Lifting 미리 구현"
**요청**: 대규모 트리 대비해서 Binary Lifting 미리 구현

**판단**:
- 단순성: ❌ (복잡도 증가)
- 테스트 가능성: ✅ (테스트 가능)
- 책임 분리: ✅ (Strategy 패턴)
- 확장성: ✅ (나중에 추가 가능)
- 성능: ❌ (지금은 불필요)

**점수**: 45점 (거부)

**결정**: ❌ 거부
**근거**: 프로토타입은 수십 개 노드만 다루므로 선형 LCA로 충분. 나중에 실제로 병목이 발생하면 추가.
**대안**: Strategy 패턴 인터페이스만 정의, LinearLCA만 구현

---

### 사례 2: "Observer 패턴 도입"
**요청**: 상태 변경 시 터미널 자동 출력

**판단**:
- 단순성: ✅ (간단한 pub-sub)
- 테스트 가능성: ✅ (Mock listener)
- 책임 분리: ✅ (Store와 UI 분리)
- 확장성: ✅ (웹 전환 시 재사용)
- 성능: ✅ (오버헤드 미미)

**점수**: 90점 (즉시 승인)

**결정**: ✅ 승인
**근거**: 상태-UI 동기화에 필수, 복잡도 낮음, 웹 전환 시에도 유용

---

### 사례 3: "Repository 패턴 + 다중 저장소"
**요청**: 메모리, 파일, DB를 모두 지원하는 Repository

**판단**:
- 단순성: ❌ (추상화 레이어 증가)
- 테스트 가능성: ✅ (Mock 가능)
- 책임 분리: ✅ (저장소 분리)
- 확장성: ✅ (저장소 교체 쉬움)
- 성능: ✅ (영향 없음)

**점수**: 65점 (조건부 승인)

**결정**: ⚠️ 조건부 거부
**근거**: 프로토타입은 메모리만 사용. 인터페이스는 정의하되 구현은 메모리만.
**대안**: 나중에 웹 전환 시 localStorage, IndexedDB 추가

---

## 4. 거부 시 커뮤니케이션 방법

### 4.1 기본 템플릿

```
[판단] ❌ 거부 / ⚠️ 조건부 승인 / ✅ 승인

[근거]
1. (주된 이유 - 판단 기준 명시)
2. (부수적 이유)

[트레이드오프]
- 얻는 것: ...
- 잃는 것: ...

[대안]
- (더 나은 방법 제시)

[질문]
- (불명확한 부분 확인)
```

### 4.2 거부 예시

```
[판단] ❌ 거부

[근거]
1. **단순성 우선**: 프로토타입은 수십 개 노드만 다루므로 선형 LCA (O(h))로 충분합니다.
2. **테스트 부담**: Binary Lifting은 전처리 로직과 2^k 테이블 검증이 추가되어 테스트 케이스가 2배 증가합니다.

[트레이드오프]
- 얻는 것: 대규모 트리(1000+ 노드)에서 성능 향상
- 잃는 것: 코드 복잡도 2배, 테스트 시간 증가, 디버깅 어려움

[대안]
Strategy 패턴 인터페이스만 정의해두고, 실제로 성능 문제가 발생하면 (측정 후) Binary Lifting 추가

[질문]
프로토타입에서 1000개 이상의 노드를 다룰 계획이 있나요?
```

---

## 5. 나의 설계 철학

### 5.1 핵심 가치
1. **"작동하는 코드 > 완벽한 설계"**
2. **"지금 필요한 것 > 미래 대비"**
3. **"단순함 > 영리함"**
4. **"검증 가능 > 이론적 완벽"**

### 5.2 경계선
**허용**:
- ✅ 필수 디자인 패턴 (문제 해결에 직접 기여)
- ✅ 인터페이스 정의 (단, 구현은 최소)
- ✅ 확장 포인트 남겨두기 (단, 미리 구현 안 함)

**거부**:
- ❌ "혹시 모를" 기능 미리 구현
- ❌ 과도한 추상화 (3단계 이상 상속/래핑)
- ❌ 성능 최적화 (병목 측정 전)
- ❌ 다중 옵션 (선택지 2개 이상)

### 5.3 예외 상황
**다음의 경우 복잡도 증가를 허용**:
1. 보안 이슈 해결
2. 데이터 무결성 보장
3. 실제 측정된 성능 병목
4. 법적/규제 요구사항

---

## 6. 최종 체크리스트

PM 요청 검토 시 다음을 확인:

- [ ] 프로토타입 목표 달성에 필수인가?
- [ ] 구현 복잡도가 1주일 이내인가?
- [ ] 단위 테스트 작성이 쉬운가?
- [ ] 기존 코드 수정이 최소화되는가?
- [ ] 대안이 있다면 더 단순한가?

**5개 중 4개 이상 YES → 승인 검토**
**3개 이하 YES → 거부 또는 대안 제시**

---

**준비 완료!**

PM님의 우려사항을 말씀해주세요. 위 기준으로 검토하고 명확히 판단하겠습니다.
