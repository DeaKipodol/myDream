# 터미널 프로토타입 아키텍처 설계서
- 작성일: 2025-11-05
- 설계자: 아키텍처 설계자
- 목적: 핵심 알고리즘 검증을 위한 터미널 기반 프로토타입
- 기술 스택: Python 3.10+
- 상태: 초안

## 1. 프로젝트 목표

### 1.1 핵심 목표
터미널 환경에서 **트리 구조 대화 시스템의 핵심 알고리즘**을 검증합니다.

**구체적 목표:**
- ✅ 트리 구조 생성 및 관리
- ✅ 노드 클릭 → 경로 전환 알고리즘 (LCA 기반)
- ✅ 체크포인트 저장/복원
- ✅ 터미널에서 대화형 시연
- ✅ 알고리즘 정확성 검증

**목표가 아닌 것:**
- ❌ UI/UX 구현 (브라우저, CSS 등)
- ❌ 백엔드 API 서버
- ❌ 데이터베이스 연동
- ❌ AI 통합

### 1.2 성공 기준
1. 사용자가 터미널에서 노드를 선택하면 경로가 정확히 전환됨
2. LCA 계산이 수학적으로 정확함
3. 체크포인트로 복원 시 상태가 완전히 복구됨
4. 코드가 50줄 이내 테스트 케이스로 검증됨

## 2. 아키텍처 개요

### 2.1 레이어 구조

```
┌─────────────────────────────────────────┐
│         Presentation Layer              │
│  ┌──────────────────────────────────┐  │
│  │   TerminalUI (사용자 입/출력)     │  │
│  └──────────────────────────────────┘  │
└─────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────┐
│          Business Layer                 │
│  ┌──────────────────────────────────┐  │
│  │   PathSwitchService              │  │
│  │   (경로 전환 조율)                │  │
│  ├──────────────────────────────────┤  │
│  │   CheckpointService              │  │
│  │   (체크포인트 관리)               │  │
│  └──────────────────────────────────┘  │
└─────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────┐
│         Algorithm Layer                 │
│  ┌──────────────────────────────────┐  │
│  │   LCACalculator                  │  │
│  │   (LCA 계산)                      │  │
│  ├──────────────────────────────────┤  │
│  │   PathReconstructor              │  │
│  │   (경로 재구성)                   │  │
│  └──────────────────────────────────┘  │
└─────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────┐
│           Data Layer                    │
│  ┌──────────────────────────────────┐  │
│  │   ConversationTree               │  │
│  │   (트리 구조 관리)                │  │
│  ├──────────────────────────────────┤  │
│  │   Node (노드 데이터)              │  │
│  ├──────────────────────────────────┤  │
│  │   Store (상태 저장소)             │  │
│  └──────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

### 2.2 데이터 흐름

```
사용자 입력 (노드 선택)
    ↓
TerminalUI.handle_node_selection()
    ↓
PathSwitchService.switch_path(current, target)
    ↓
LCACalculator.calculate(current, target) → LCA 노드
    ↓
PathReconstructor.reconstruct(lca, target) → 새 경로
    ↓
Store.update_active_path(new_path)
    ↓
CheckpointService.create_checkpoint() (선택)
    ↓
TerminalUI.display_result()
```

## 3. 디자인 패턴 적용

### 3.1 필수 패턴 (MVP)

#### 3.1.1 Memento (체크포인트)
**목적**: 상태 저장/복원

**구현**:
```python
class Checkpoint:
    """불변 스냅샷"""
    def __init__(self, active_path: List[str], timestamp: str):
        self._active_path = tuple(active_path)  # 불변
        self._timestamp = timestamp

    def restore(self) -> List[str]:
        return list(self._active_path)
```

**사용 이유**:
- 핵심 기능인 "되돌리기" 구현에 필수
- 상태를 불변 객체로 저장하여 안전성 보장
- 복원 시 정확히 동일한 상태로 복구

#### 3.1.2 Observer (경량 버전)
**목적**: 상태 변경 알림

**구현**:
```python
class Store:
    """단순 상태 저장소 + 옵저버"""
    def __init__(self):
        self._state = {}
        self._listeners = []

    def subscribe(self, listener):
        self._listeners.append(listener)

    def update(self, key, value):
        self._state[key] = value
        for listener in self._listeners:
            listener(key, value)
```

**사용 이유**:
- 터미널 UI가 상태 변경을 자동 감지하여 출력
- 디버깅 시 상태 변경 추적 용이

#### 3.1.3 Strategy (선택적)
**목적**: LCA 알고리즘 교체 가능성

**구현**:
```python
class LCAStrategy(ABC):
    @abstractmethod
    def calculate(self, tree, node_a, node_b) -> str:
        pass

class LinearLCA(LCAStrategy):
    """선형 LCA (O(h))"""
    def calculate(self, tree, node_a, node_b) -> str:
        # 구현...
        pass

class BinaryLiftingLCA(LCAStrategy):
    """Binary Lifting (O(log N))"""
    def calculate(self, tree, node_a, node_b) -> str:
        # 구현...
        pass
```

**사용 여부**: MVP에서는 LinearLCA만 구현, 나중에 추가 가능

### 3.2 패턴 적용 근거

| 패턴 | 적용 | 근거 |
|------|------|------|
| Memento | ✅ 필수 | 체크포인트 핵심 기능 |
| Observer | ✅ 필수 | 상태-UI 동기화 |
| Strategy | ⏸️ 보류 | 일단 선형 LCA만 구현 |
| Repository | ❌ 불필요 | 메모리 저장만 사용 |
| Flux-lite | ❌ 과설계 | 터미널 UI는 단순 |

## 4. 핵심 클래스 및 객체

### 4.1 Data Layer

#### 4.1.1 Node (노드)
```python
from dataclasses import dataclass
from typing import Optional, List

@dataclass
class Node:
    """대화 노드"""
    id: str
    parent_id: Optional[str]
    role: str  # 'user' | 'assistant' | 'system'
    content: str
    depth: int
    children_ids: List[str] = None  # 캐시용 (옵션)

    def __post_init__(self):
        if self.children_ids is None:
            self.children_ids = []
```

**책임**:
- 노드 데이터 저장
- 부모-자식 관계 표현
- 불변성 유지 (dataclass frozen=True 옵션 고려)

#### 4.1.2 ConversationTree (대화 트리)
```python
class ConversationTree:
    """트리 구조 관리"""
    def __init__(self, root_id: str):
        self.root_id = root_id
        self.nodes: Dict[str, Node] = {}

    def add_node(self, node: Node):
        """노드 추가"""
        self.nodes[node.id] = node
        if node.parent_id:
            parent = self.nodes[node.parent_id]
            parent.children_ids.append(node.id)

    def get_node(self, node_id: str) -> Optional[Node]:
        """노드 조회"""
        return self.nodes.get(node_id)

    def get_children(self, node_id: str) -> List[Node]:
        """자식 노드들 조회"""
        node = self.get_node(node_id)
        if not node:
            return []
        return [self.nodes[cid] for cid in node.children_ids]

    def get_path_to_root(self, node_id: str) -> List[str]:
        """노드에서 루트까지 경로"""
        path = []
        current_id = node_id
        while current_id:
            path.insert(0, current_id)
            node = self.get_node(current_id)
            current_id = node.parent_id if node else None
        return path
```

**책임**:
- 노드 추가/조회
- 부모-자식 관계 관리
- 경로 조회

#### 4.1.3 Store (상태 저장소)
```python
class Store:
    """전역 상태 관리"""
    def __init__(self):
        self.active_path: List[str] = []
        self.selected_node_id: str = None
        self.checkpoints: List[Checkpoint] = []
        self._listeners = []

    def subscribe(self, listener):
        self._listeners.append(listener)

    def set_active_path(self, path: List[str]):
        self.active_path = path
        self._notify('active_path', path)

    def set_selected_node(self, node_id: str):
        self.selected_node_id = node_id
        self._notify('selected_node', node_id)

    def _notify(self, key, value):
        for listener in self._listeners:
            listener(key, value)
```

**책임**:
- 활성 경로 저장
- 선택 노드 저장
- 체크포인트 목록 관리
- 상태 변경 알림

### 4.2 Algorithm Layer

#### 4.2.1 LCACalculator (LCA 계산)
```python
class LCACalculator:
    """LCA 계산 (선형 방식)"""

    @staticmethod
    def calculate(tree: ConversationTree, node_a_id: str, node_b_id: str) -> str:
        """
        LCA 계산

        알고리즘:
        1. 두 노드의 깊이를 맞춤
        2. 동시에 부모로 상승하여 공통 조상 찾기

        시간 복잡도: O(h) where h = tree height
        """
        node_a = tree.get_node(node_a_id)
        node_b = tree.get_node(node_b_id)

        if not node_a or not node_b:
            raise ValueError("노드를 찾을 수 없습니다")

        # 1. 깊이 맞추기
        while node_a.depth > node_b.depth:
            node_a = tree.get_node(node_a.parent_id)

        while node_b.depth > node_a.depth:
            node_b = tree.get_node(node_b.parent_id)

        # 2. 동시 상승
        while node_a.id != node_b.id:
            node_a = tree.get_node(node_a.parent_id)
            node_b = tree.get_node(node_b.parent_id)

            if not node_a or not node_b:
                raise ValueError("LCA를 찾을 수 없습니다")

        return node_a.id
```

**책임**:
- LCA 계산 (선형 방식)
- 깊이 정규화
- 에러 핸들링

**테스트 케이스**:
```python
# 예시 트리:
#     A
#    / \
#   B   C
#  / \   \
# D   F   G

assert LCACalculator.calculate(tree, 'D', 'F') == 'B'
assert LCACalculator.calculate(tree, 'D', 'G') == 'A'
assert LCACalculator.calculate(tree, 'D', 'B') == 'B'
```

#### 4.2.2 PathReconstructor (경로 재구성)
```python
class PathReconstructor:
    """경로 재구성 (prefix + suffix)"""

    @staticmethod
    def reconstruct(tree: ConversationTree, lca_id: str, target_id: str) -> List[str]:
        """
        LCA에서 목표 노드까지의 경로 구성

        Returns:
            [root, ..., lca, ..., target]
        """
        # 루트 → LCA 경로
        prefix = tree.get_path_to_root(lca_id)

        # LCA → 목표 경로
        suffix = []
        current_id = target_id
        while current_id != lca_id:
            suffix.insert(0, current_id)
            node = tree.get_node(current_id)
            current_id = node.parent_id if node else None

        # 합치기 (LCA 중복 제거)
        return prefix + suffix
```

**책임**:
- 경로 재구성
- prefix/suffix 계산
- LCA 중복 제거

### 4.3 Business Layer

#### 4.3.1 PathSwitchService (경로 전환)
```python
class PathSwitchService:
    """경로 전환 비즈니스 로직"""

    def __init__(self, tree: ConversationTree, store: Store):
        self.tree = tree
        self.store = store
        self.lca_calculator = LCACalculator()
        self.path_reconstructor = PathReconstructor()

    def switch_path(self, current_leaf_id: str, target_node_id: str) -> List[str]:
        """
        경로 전환

        1. LCA 계산
        2. 경로 재구성
        3. 상태 업데이트

        Returns:
            새 활성 경로
        """
        # 동일 노드 클릭 시 no-op
        if current_leaf_id == target_node_id:
            return self.store.active_path

        # 1. LCA 계산
        lca_id = self.lca_calculator.calculate(
            self.tree,
            current_leaf_id,
            target_node_id
        )

        # 2. 경로 재구성
        new_path = self.path_reconstructor.reconstruct(
            self.tree,
            lca_id,
            target_node_id
        )

        # 3. 상태 업데이트
        self.store.set_active_path(new_path)
        self.store.set_selected_node(target_node_id)

        return new_path
```

**책임**:
- 경로 전환 조율
- LCA, PathReconstructor 호출
- 상태 업데이트

#### 4.3.2 CheckpointService (체크포인트)
```python
from datetime import datetime

class Checkpoint:
    """불변 체크포인트"""
    def __init__(self, active_path: List[str], reason: str):
        self._active_path = tuple(active_path)  # 불변
        self._timestamp = datetime.now().isoformat()
        self._reason = reason

    @property
    def active_path(self) -> List[str]:
        return list(self._active_path)

    @property
    def timestamp(self) -> str:
        return self._timestamp

    @property
    def reason(self) -> str:
        return self._reason

class CheckpointService:
    """체크포인트 관리"""

    def __init__(self, store: Store):
        self.store = store

    def create_checkpoint(self, reason: str = "manual") -> Checkpoint:
        """체크포인트 생성"""
        checkpoint = Checkpoint(self.store.active_path, reason)
        self.store.checkpoints.append(checkpoint)
        return checkpoint

    def restore_checkpoint(self, checkpoint: Checkpoint):
        """체크포인트 복원"""
        restored_path = checkpoint.active_path
        self.store.set_active_path(restored_path)
        self.store.set_selected_node(restored_path[-1])

    def list_checkpoints(self) -> List[Checkpoint]:
        """체크포인트 목록"""
        return self.store.checkpoints
```

**책임**:
- 체크포인트 생성
- 체크포인트 복원
- 체크포인트 목록 관리

### 4.4 Presentation Layer

#### 4.4.1 TerminalUI (터미널 인터페이스)
```python
class TerminalUI:
    """터미널 사용자 인터페이스"""

    def __init__(self, tree: ConversationTree, store: Store,
                 path_service: PathSwitchService, checkpoint_service: CheckpointService):
        self.tree = tree
        self.store = store
        self.path_service = path_service
        self.checkpoint_service = checkpoint_service

        # 상태 변경 구독
        self.store.subscribe(self.on_state_change)

    def on_state_change(self, key, value):
        """상태 변경 시 호출"""
        if key == 'active_path':
            print(f"\n✓ 경로 변경: {' → '.join(value)}")

    def display_tree(self):
        """트리 구조 출력"""
        print("\n=== 대화 트리 ===")
        self._display_node(self.tree.root_id, indent=0)

    def _display_node(self, node_id: str, indent: int):
        """재귀적 노드 출력"""
        node = self.tree.get_node(node_id)
        if not node:
            return

        # 활성 경로 하이라이트
        marker = "●" if node_id in self.store.active_path else "○"
        print("  " * indent + f"{marker} {node_id}: {node.content[:30]}")

        for child_id in node.children_ids:
            self._display_node(child_id, indent + 1)

    def display_active_path(self):
        """활성 경로 출력"""
        print("\n=== 활성 경로 ===")
        print(" → ".join(self.store.active_path))

    def display_messages(self):
        """대화 메시지 출력"""
        print("\n=== 대화 내용 ===")
        for node_id in self.store.active_path:
            node = self.tree.get_node(node_id)
            if node:
                role = node.role.upper()
                print(f"[{role}] {node.content}")

    def display_checkpoints(self):
        """체크포인트 목록 출력"""
        print("\n=== 체크포인트 ===")
        checkpoints = self.checkpoint_service.list_checkpoints()
        for i, cp in enumerate(checkpoints):
            path_str = " → ".join(cp.active_path)
            print(f"{i+1}. [{cp.timestamp}] {cp.reason}: {path_str}")

    def main_loop(self):
        """메인 루프"""
        while True:
            print("\n" + "="*50)
            print("명령어: [t]트리 [p]경로 [m]메시지 [s]전환 [c]체크포인트 [r]복원 [q]종료")
            cmd = input(">>> ").strip().lower()

            if cmd == 't':
                self.display_tree()
            elif cmd == 'p':
                self.display_active_path()
            elif cmd == 'm':
                self.display_messages()
            elif cmd == 's':
                self.handle_switch()
            elif cmd == 'c':
                self.handle_checkpoint()
            elif cmd == 'r':
                self.handle_restore()
            elif cmd == 'q':
                print("종료합니다.")
                break
            else:
                print("알 수 없는 명령어입니다.")

    def handle_switch(self):
        """경로 전환 처리"""
        self.display_tree()
        target = input("\n전환할 노드 ID: ").strip()

        if target not in self.tree.nodes:
            print("❌ 노드를 찾을 수 없습니다.")
            return

        current = self.store.selected_node_id or self.tree.root_id

        try:
            new_path = self.path_service.switch_path(current, target)
            print(f"✓ 경로 전환 완료: {' → '.join(new_path)}")
        except Exception as e:
            print(f"❌ 경로 전환 실패: {e}")

    def handle_checkpoint(self):
        """체크포인트 저장"""
        reason = input("체크포인트 이유 (선택): ").strip() or "manual"
        cp = self.checkpoint_service.create_checkpoint(reason)
        print(f"✓ 체크포인트 저장: {' → '.join(cp.active_path)}")

    def handle_restore(self):
        """체크포인트 복원"""
        self.display_checkpoints()
        checkpoints = self.checkpoint_service.list_checkpoints()

        if not checkpoints:
            print("저장된 체크포인트가 없습니다.")
            return

        try:
            idx = int(input("\n복원할 체크포인트 번호: ")) - 1
            if 0 <= idx < len(checkpoints):
                self.checkpoint_service.restore_checkpoint(checkpoints[idx])
                print(f"✓ 체크포인트 복원 완료: {' → '.join(self.store.active_path)}")
            else:
                print("❌ 잘못된 번호입니다.")
        except ValueError:
            print("❌ 숫자를 입력하세요.")
```

**책임**:
- 사용자 입력 처리
- 화면 출력
- 명령어 라우팅
- 상태 변경 시각화

## 5. 파일 구조

```
prototype/
├── main.py                  # 진입점
├── models/
│   ├── __init__.py
│   ├── node.py              # Node 클래스
│   └── checkpoint.py        # Checkpoint 클래스
├── data/
│   ├── __init__.py
│   ├── tree.py              # ConversationTree
│   └── store.py             # Store
├── algorithms/
│   ├── __init__.py
│   ├── lca.py               # LCACalculator
│   └── path.py              # PathReconstructor
├── services/
│   ├── __init__.py
│   ├── path_switch.py       # PathSwitchService
│   └── checkpoint.py        # CheckpointService
├── ui/
│   ├── __init__.py
│   └── terminal.py          # TerminalUI
├── tests/
│   ├── __init__.py
│   ├── test_lca.py
│   ├── test_path_switch.py
│   └── test_checkpoint.py
└── fixtures/
    ├── __init__.py
    └── sample_tree.py       # 샘플 데이터 (A~I 트리)
```

## 6. 샘플 데이터 (픽스처)

```python
# fixtures/sample_tree.py

def create_sample_tree() -> ConversationTree:
    """
    샘플 트리 생성

         A (root)
        / \
       B   C
      / \   \
     D   F   G
    """
    tree = ConversationTree(root_id='A')

    # 노드 생성
    nodes = [
        Node('A', None, 'system', '대화 시작', 0),
        Node('B', 'A', 'user', '진로 고민이 있어요', 1),
        Node('C', 'A', 'user', '인간관계 문제가 있어요', 1),
        Node('D', 'B', 'assistant', '진로에 대해 더 자세히 말씀해주세요', 2),
        Node('F', 'B', 'assistant', '먼저 본인의 흥미를 파악해보세요', 2),
        Node('G', 'C', 'assistant', '어떤 인간관계 문제인가요?', 2),
    ]

    for node in nodes:
        tree.add_node(node)

    return tree
```

## 7. 구현 순서

### 7.1 1단계: 기초 구조
- [ ] Node, ConversationTree 클래스
- [ ] 샘플 트리 생성 (A~G)
- [ ] 트리 출력 확인

### 7.2 2단계: 핵심 알고리즘
- [ ] LCACalculator 구현
- [ ] PathReconstructor 구현
- [ ] 테스트 케이스 작성 및 검증

### 7.3 3단계: 경로 전환
- [ ] Store 구현
- [ ] PathSwitchService 구현
- [ ] 경로 전환 시연

### 7.4 4단계: 체크포인트
- [ ] Checkpoint 클래스
- [ ] CheckpointService 구현
- [ ] 저장/복원 시연

### 7.5 5단계: UI 완성
- [ ] TerminalUI 구현
- [ ] 명령어 처리
- [ ] 전체 통합 시연

## 8. 테스트 계획

### 8.1 LCA 테스트
```python
def test_lca_siblings():
    """형제 노드의 LCA는 부모"""
    assert LCACalculator.calculate(tree, 'D', 'F') == 'B'

def test_lca_cousins():
    """사촌 노드의 LCA는 조부모"""
    assert LCACalculator.calculate(tree, 'D', 'G') == 'A'

def test_lca_ancestor():
    """조상-자손의 LCA는 조상 자신"""
    assert LCACalculator.calculate(tree, 'D', 'B') == 'B'
```

### 8.2 경로 전환 테스트
```python
def test_path_switch_sibling():
    """형제 노드로 전환"""
    # A → B → D에서 F 클릭
    new_path = path_service.switch_path('D', 'F')
    assert new_path == ['A', 'B', 'F']

def test_path_switch_cousin():
    """사촌 노드로 전환"""
    # A → B → D에서 G 클릭
    new_path = path_service.switch_path('D', 'G')
    assert new_path == ['A', 'C', 'G']
```

### 8.3 체크포인트 테스트
```python
def test_checkpoint_save_restore():
    """체크포인트 저장 및 복원"""
    # 1. 초기 경로: A → B → D
    store.set_active_path(['A', 'B', 'D'])

    # 2. 체크포인트 저장
    cp = checkpoint_service.create_checkpoint("before_switch")

    # 3. 경로 전환: A → C → G
    path_service.switch_path('D', 'G')
    assert store.active_path == ['A', 'C', 'G']

    # 4. 복원
    checkpoint_service.restore_checkpoint(cp)
    assert store.active_path == ['A', 'B', 'D']
```

## 9. 실행 예시

```bash
$ python main.py

=== 대화 트리 ===
● A: 대화 시작
  ● B: 진로 고민이 있어요
    ● D: 진로에 대해 더 자세히 말씀해주세요
    ○ F: 먼저 본인의 흥미를 파악해보세요
  ○ C: 인간관계 문제가 있어요
    ○ G: 어떤 인간관계 문제인가요?

==================================================
명령어: [t]트리 [p]경로 [m]메시지 [s]전환 [c]체크포인트 [r]복원 [q]종료
>>> s

전환할 노드 ID: F

✓ 경로 전환 완료: A → B → F

==================================================
명령어: [t]트리 [p]경로 [m]메시지 [s]전환 [c]체크포인트 [r]복원 [q]종료
>>> c

체크포인트 이유 (선택): F 경로 시도

✓ 체크포인트 저장: A → B → F
```

## 10. 다음 단계

1. **구현 시작**: 파일 구조 생성
2. **기초 검증**: Node, Tree, LCA 구현
3. **알고리즘 검증**: 테스트 케이스 통과
4. **UI 통합**: 터미널 시연
5. **웹 전환 준비**: 알고리즘 재사용

---

**PM님, 이 설계로 진행해도 괜찮을까요?**

핵심 요약:
- ✅ 터미널 기반 프로토타입
- ✅ 핵심 알고리즘 집중 (LCA, 경로 전환, 체크포인트)
- ✅ 필수 패턴만 적용 (Memento, Observer 경량)
- ✅ 명확한 클래스 구조 (Node, Tree, Services, UI)
- ✅ 테스트 가능한 설계

수정이나 추가 요구사항이 있으면 말씀해주세요!
