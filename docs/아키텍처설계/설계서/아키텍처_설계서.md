# 아키텍처 설계서
- 작성일: 2025-11-05
- 설계자: 아키텍처 설계자
- 상태: 초안
- 버전: 1.0

## 1. 아키텍처 개요

### 1.1 전체 구조

```
┌─────────────────────────────────────────────────────────┐
│                   Presentation Layer                     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │   Web UI     │  │  REST API    │  │  WebSocket   │  │
│  │ (HTML/CSS/JS)│  │  Controller  │  │   Handler    │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└─────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────┐
│                    Business Layer                        │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │ Conversation │  │   Checkpoint │  │  AI Service  │  │
│  │   Service    │  │   Service    │  │              │  │
│  ├──────────────┤  ├──────────────┤  ├──────────────┤  │
│  │ Path Switch  │  │   Snapshot   │  │   Context    │  │
│  │   Service    │  │   Service    │  │   Builder    │  │
│  ├──────────────┤  ├──────────────┤  └──────────────┘  │
│  │ LCA Service  │  │    Shelf     │                     │
│  │              │  │   Service    │                     │
│  └──────────────┘  └──────────────┘                     │
└─────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────┐
│                     Data Layer                           │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │ Conversation │  │   Checkpoint │  │    Cache     │  │
│  │  Repository  │  │  Repository  │  │ (Redis/Mem)  │  │
│  ├──────────────┤  ├──────────────┤  └──────────────┘  │
│  │     Node     │  │    Shelf     │                     │
│  │  Repository  │  │  Repository  │                     │
│  └──────────────┘  └──────────────┘                     │
└─────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────┐
│                    Infrastructure                        │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │   MongoDB    │  │    Redis     │  │  AI Provider │  │
│  │  (Database)  │  │   (Cache)    │  │ (OpenAI/etc) │  │
│  └──────────────┘  └──────────────┘  └──────────────┘  │
└─────────────────────────────────────────────────────────┘
```

### 1.2 핵심 원칙
1. **레이어 분리**: 각 레이어는 명확한 책임을 가지며 하위 레이어에만 의존
2. **단일 책임**: 각 컴포넌트는 하나의 명확한 역할 수행
3. **추상화**: Repository 패턴으로 데이터 접근 추상화
4. **확장성**: 프로바이더 추상화로 AI, 캐시, DB 교체 가능
5. **테스트 가능성**: 각 레이어를 독립적으로 테스트 가능

## 2. 레이어별 상세 설계

### 2.1 Presentation Layer

#### 책임
- 사용자 입력 처리
- 화면 렌더링
- API 요청/응답 처리
- 상태 관리 (activePath, selectedNode)

#### 주요 컴포넌트

**Web UI (프론트엔드)**
- `TreeView.js`: 트리 구조 시각화, 노드 클릭 핸들링
- `ChatView.js`: 대화 패널, 메시지 표시
- `Breadcrumbs.js`: 현재 경로 표시
- `CheckpointList.js`: 체크포인트 목록 및 복원
- `StateManager.js`: 전역 상태 관리

**API Controller (백엔드)**
- `ConversationController.py`: 대화 CRUD
- `PathController.py`: 경로 전환 API
- `CheckpointController.py`: 체크포인트 API
- `AIController.py`: AI 응답 생성 API

**실시간 통신**
- `WebSocketHandler.py`: 실시간 경로 전환 알림 (옵션)

### 2.2 Business Layer

#### 책임
- 비즈니스 로직 수행
- 경로 계산, LCA 계산, 체크포인트 생성
- AI 컨텍스트 구성
- 트랜잭션 조율

#### 주요 서비스

**ConversationService**
- 대화 생성, 노드 추가
- 루트→노드 경로 조회
- 대화 유효성 검증

**PathSwitchService**
- 경로 전환 조율
- LCA 계산 호출
- 전/후 체크포인트 생성
- 보존 영역 이동 마킹

**LCAService**
- LCA 계산 (선형 방식 / Binary Lifting)
- 경로 재구성 (prefix + suffix)
- 노드 수 임계값 기반 알고리즘 전환

**CheckpointService**
- 체크포인트 생성 (스냅샷 저장)
- 체크포인트 목록 조회
- 복원 로직 (스냅샷 로드 → activePath 교체)

**SnapshotService**
- 스냅샷 직렬화/역직렬화
- 해시 계산 및 무결성 검증
- 중복 제거

**ShelfService**
- 보존 스레드 마킹
- 보존 목록 조회
- 재활성화 로직

**AIService**
- AI 응답 생성 요청
- 프로바이더 추상화 (OpenAI, Anthropic 등)
- 토큰 한도 관리
- 재시도 로직

**ContextBuilder**
- 활성 경로 기반 컨텍스트 블록 구성
- 시스템 프롬프트 조합
- 토큰 수 계산 및 슬라이싱

### 2.3 Data Layer

#### 책임
- 데이터 CRUD
- 쿼리 최적화
- 캐시 관리
- 트랜잭션 처리

#### 주요 Repository

**ConversationRepository**
- `create(conversation)`: 대화 생성
- `findById(id)`: 대화 조회
- `update(id, data)`: 대화 업데이트
- `delete(id)`: 소프트 삭제

**NodeRepository**
- `create(node)`: 노드 생성
- `findById(id)`: 노드 조회
- `findByConversationId(convId)`: 대화의 모든 노드 조회
- `findPathToRoot(nodeId)`: 루트까지 경로 조회
- `findChildren(parentId)`: 자식 노드 조회

**CheckpointRepository**
- `create(checkpoint)`: 체크포인트 생성
- `findByConversationId(convId)`: 체크포인트 목록 조회
- `findById(id)`: 체크포인트 조회
- `deleteOld(days)`: 오래된 체크포인트 삭제

**ShelfRepository**
- `create(shelf)`: 보존 스레드 생성
- `findByConversationId(convId)`: 보존 목록 조회

**Cache (Redis/Memory)**
- 경로 조회 캐시 (key: `path:{nodeId}`, value: `[A, B, C]`)
- LCA 계산 캐시 (key: `lca:{nodeA}:{nodeB}`, value: `L`)
- TTL: 15분

### 2.4 Infrastructure Layer

#### MongoDB 스키마 설계

**conversations 컬렉션**
```javascript
{
  _id: ObjectId,
  ownerId: String,       // 사용자 ID
  title: String,
  rootId: String,        // 루트 노드 ID
  createdAt: Date,
  updatedAt: Date,
  meta: {
    domain: String,      // 도메인 태그 (불안/진로/대인)
    tags: [String]
  }
}
```

**nodes 컬렉션**
```javascript
{
  _id: String,           // UUID
  conversationId: String,
  parentId: String,      // null이면 루트
  role: String,          // 'user' | 'assistant' | 'system'
  type: String,          // 'message' | 'checkpoint'
  content: String,       // 메시지 본문
  depth: Number,         // 루트로부터 깊이
  createdAt: Date,
  meta: {
    score: Number,       // 품질 점수 (옵션)
    tags: [String],
    source: String       // AI 프로바이더
  }
}
```
- 인덱스: `{conversationId: 1, parentId: 1, depth: 1}`
- 인덱스: `{conversationId: 1, createdAt: -1}`

**checkpoints 컬렉션**
```javascript
{
  _id: String,           // UUID
  conversationId: String,
  activePathIds: [String], // 스냅샷 시점의 경로
  reason: String,        // 생성 이유
  createdAt: Date,
  snapshotHash: String   // SHA256 해시
}
```
- 인덱스: `{conversationId: 1, createdAt: -1}`

**shelves 컬렉션**
```javascript
{
  _id: String,
  conversationId: String,
  fromCheckpointId: String,
  hiddenPathIds: [String], // 보존된 경로
  createdAt: Date,
  note: String           // 사용자 메모 (옵션)
}
```
- 인덱스: `{conversationId: 1}`

**sessions 컬렉션**
```javascript
{
  _id: String,
  conversationId: String,
  activeCheckpointId: String,
  uiState: {
    selectedNodeId: String,
    scrollPosition: Number
  },
  createdAt: Date,
  updatedAt: Date
}
```

**users 컬렉션**
```javascript
{
  _id: String,
  email: String,
  hashedPassword: String,
  roles: [String],       // ['user', 'admin']
  createdAt: Date
}
```
- 인덱스: `{email: 1}` (unique)

#### Redis 캐시 전략
- **경로 캐시**: `path:{nodeId}` → `[A, B, C, D]` (TTL: 15분)
- **LCA 캐시**: `lca:{nodeA}:{nodeB}` → `L` (TTL: 15분)
- **세션 캐시**: `session:{userId}` → 활성 세션 정보 (TTL: 30분)

## 3. 핵심 알고리즘 상세

### 3.1 경로 전환 알고리즘

```python
def switch_path(conversation_id, current_leaf_id, target_node_id):
    """
    경로 전환 메인 로직
    """
    # 1. 버전 검증 (동시 전환 방지)
    session = validate_session_version(conversation_id)

    # 2. LCA 계산
    lca_id = lca_service.calculate(current_leaf_id, target_node_id)

    # 3. 경로 재구성
    prefix = node_repo.find_path_to_node(lca_id)
    suffix = node_repo.find_path_from_node(lca_id, target_node_id)
    new_active_path = prefix + suffix[1:]  # LCA 중복 제거

    # 4. 전환 전 체크포인트 생성
    before_checkpoint = checkpoint_service.create(
        conversation_id,
        active_path=[session.activePath],
        reason="before_switch"
    )

    # 5. 보존 영역 이동 (기존 분기)
    old_branch = session.activePath[len(prefix):]
    shelf_service.mark_hidden(conversation_id, old_branch, before_checkpoint.id)

    # 6. 활성 경로 교체
    session.activePath = new_active_path
    session.save()

    # 7. 전환 후 체크포인트 생성
    after_checkpoint = checkpoint_service.create(
        conversation_id,
        active_path=new_active_path,
        reason="after_switch"
    )

    return {
        "activePathIds": new_active_path,
        "lcaNodeId": lca_id,
        "checkpointBeforeId": before_checkpoint.id,
        "checkpointAfterId": after_checkpoint.id
    }
```

### 3.2 LCA 계산 (선형 방식)

```python
def calculate_lca_linear(node_a_id, node_b_id):
    """
    선형 LCA 계산 (소규모 트리용)
    시간 복잡도: O(h) where h = tree height
    """
    # 1. 두 노드 조회
    node_a = node_repo.find_by_id(node_a_id)
    node_b = node_repo.find_by_id(node_b_id)

    # 2. 깊이 맞추기
    while node_a.depth > node_b.depth:
        node_a = node_repo.find_by_id(node_a.parentId)
    while node_b.depth > node_a.depth:
        node_b = node_repo.find_by_id(node_b.parentId)

    # 3. 동시 상승하여 공통 조상 찾기
    while node_a.id != node_b.id:
        node_a = node_repo.find_by_id(node_a.parentId)
        node_b = node_repo.find_by_id(node_b.parentId)

    return node_a.id
```

### 3.3 LCA 계산 (Binary Lifting)

```python
def calculate_lca_binary_lifting(node_a_id, node_b_id):
    """
    Binary Lifting LCA 계산 (대규모 트리용)
    시간 복잡도: O(log N)
    전처리: O(N log N)
    """
    # 1. 전처리 테이블 조회 (캐시됨)
    jump_table_a = preprocess_cache.get(node_a_id)
    jump_table_b = preprocess_cache.get(node_b_id)

    # 2. 깊이 맞추기 (2^k 점프)
    node_a, node_b = equalize_depth(node_a_id, node_b_id, jump_table_a, jump_table_b)

    # 3. Binary Lifting으로 LCA 직전까지 이동
    for k in range(MAX_LOG, -1, -1):
        ancestor_a = jump_table_a[k]
        ancestor_b = jump_table_b[k]
        if ancestor_a != ancestor_b:
            node_a = ancestor_a
            node_b = ancestor_b

    # 4. 한 단계 올려서 LCA 반환
    return node_repo.find_by_id(node_a).parentId
```

### 3.4 체크포인트 복원 알고리즘

```python
def restore_checkpoint(conversation_id, checkpoint_id):
    """
    체크포인트 복원
    """
    # 1. 체크포인트 조회
    checkpoint = checkpoint_repo.find_by_id(checkpoint_id)

    # 2. 무결성 검증
    if not verify_snapshot_hash(checkpoint):
        raise IntegrityError("Checkpoint hash mismatch")

    # 3. 활성 경로 교체
    session = session_repo.find_by_conversation_id(conversation_id)
    old_path = session.activePath
    session.activePath = checkpoint.activePathIds
    session.save()

    # 4. 보존 영역 업데이트 (기존 경로)
    shelf_service.mark_hidden(conversation_id, old_path, checkpoint_id)

    # 5. 복원 후 체크포인트 생성
    new_checkpoint = checkpoint_service.create(
        conversation_id,
        active_path=checkpoint.activePathIds,
        reason="restored"
    )

    return {
        "activePathIds": checkpoint.activePathIds,
        "restoredAt": datetime.now()
    }
```

## 4. API 설계

### 4.1 REST API 엔드포인트

#### 대화 관리
- `POST /api/v1/conversations`: 대화 생성
- `GET /api/v1/conversations/{id}`: 대화 조회
- `POST /api/v1/conversations/{id}/nodes`: 노드 추가

#### 경로 관리
- `GET /api/v1/conversations/{id}/nodes/{nodeId}/path`: 경로 조회
- `POST /api/v1/conversations/{id}/switch`: 경로 전환
  ```json
  {
    "currentLeafId": "D",
    "targetNodeId": "F",
    "clientVersion": 123
  }
  ```
  응답:
  ```json
  {
    "activePathIds": ["A", "B", "F"],
    "lcaNodeId": "B",
    "checkpointBeforeId": "ckpt-001",
    "checkpointAfterId": "ckpt-002"
  }
  ```

#### 체크포인트
- `POST /api/v1/conversations/{id}/checkpoints`: 체크포인트 생성
- `GET /api/v1/conversations/{id}/checkpoints`: 목록 조회
- `POST /api/v1/conversations/{id}/restore`: 복원
  ```json
  {
    "checkpointId": "ckpt-001"
  }
  ```

#### AI 응답
- `POST /api/v1/ai/generate`: AI 응답 생성
  ```json
  {
    "conversationId": "conv-001",
    "contextBlockIds": ["A", "B", "F"],
    "prompt": "사용자 입력",
    "domainTags": ["불안"]
  }
  ```

#### 보존 스레드
- `GET /api/v1/conversations/{id}/shelves`: 보존 목록 조회

### 4.2 오류 코드
- `400 Bad Request`: 잘못된 노드 참조, 유효성 오류
- `404 Not Found`: 대화/노드/체크포인트 없음
- `409 Conflict`: 동시 전환 충돌, 버전 불일치
- `422 Unprocessable Entity`: 병합 불가, 토큰 한도 초과
- `500 Internal Server Error`: 서버 오류

## 5. 설계 패턴

### 5.1 Repository 패턴
- 데이터 접근을 추상화
- 비즈니스 로직과 데이터 레이어 분리
- 테스트 시 Mock 주입 가능

### 5.2 Strategy 패턴
- LCAService: 선형 vs Binary Lifting 전략 교체
- CacheProvider: Redis vs Memory 전략 교체
- AIProvider: OpenAI vs Anthropic 전략 교체

### 5.3 Factory 패턴
- NodeFactory: 노드 타입별 생성
- CheckpointFactory: 체크포인트 생성

### 5.4 Observer 패턴
- 경로 전환 이벤트 발생 → UI 갱신
- WebSocket 실시간 알림 (옵션)

## 6. 성능 최적화 전략

### 6.1 캐싱
- Redis 경로 캐시 (적중률 목표 80%)
- LCA 계산 결과 캐시
- 세션 정보 캐시

### 6.2 인덱스 최적화
- 복합 인덱스: `{conversationId, parentId, depth}`
- 시간 기반 인덱스: `{conversationId, createdAt}`

### 6.3 쿼리 최적화
- `findPathToRoot`: 재귀 대신 반복문 사용
- 배치 조회: 여러 노드를 한 번에 조회

### 6.4 비동기 처리
- AI 응답 생성은 비동기 작업
- 체크포인트 생성은 백그라운드 작업 (옵션)

## 7. 보안 설계

### 7.1 인증
- JWT 기반 토큰 인증
- 토큰 만료: 1시간 (Access), 7일 (Refresh)

### 7.2 권한
- RBAC: `user`, `admin` 역할
- 대화 소유권 검증

### 7.3 데이터 보호
- 비밀번호: bcrypt 해싱
- 민감 데이터: AES-256 암호화
- 전송: HTTPS/TLS

### 7.4 속도 제한
- IP별 속도 제한: 분당 100회
- 사용자별 속도 제한: 분당 60회

### 7.5 감사 로그
- 경로 전환, 복원, 삭제 이벤트 기록
- 로그 보존: 1년

## 8. 확장성 고려사항

### 8.1 수평 확장
- 백엔드 API: 무상태(stateless) 설계로 다중 인스턴스 가능
- MongoDB: 샤딩 지원
- Redis: 클러스터 모드

### 8.2 수직 확장
- 노드 수 임계값 초과 시 Binary Lifting 자동 전환
- 인덱스 튜닝, 쿼리 최적화

### 8.3 비동기 작업
- 체크포인트 생성: 셀러리(Celery) 큐
- AI 응답: 스트리밍 (Server-Sent Events)

## 9. 모니터링 및 관측성

### 9.1 핵심 지표
- 경로 전환 지연 (p50, p95, p99)
- 체크포인트 복원 성공률
- AI 응답 지연
- 캐시 적중률
- 에러 비율

### 9.2 로깅
- 구조화 로그 (JSON 형식)
- 로그 레벨: ERROR, WARN, INFO, DEBUG
- 로그 수집: ELK 스택 또는 Datadog

### 9.3 알람
- 응답 지연 임계값 초과
- 에러율 5% 초과
- 캐시 적중률 70% 미만

## 10. 설계 의사결정 근거

### 10.1 왜 NoSQL(MongoDB)인가?
- 트리 구조는 부모-자식 참조로 표현 (관계형 DB도 가능)
- 하지만 스키마 유연성이 중요 (메타 필드 확장)
- 문서 지향 모델이 노드 구조와 자연스럽게 매칭
- 샤딩을 통한 수평 확장 용이

**대안 비교:**
- PostgreSQL: 관계 무결성 강점, 하지만 JSON 필드로 유연성 확보 가능
- DynamoDB: 서버리스 장점, 하지만 쿼리 제약 및 비용

**결정**: MongoDB 선택 (유연성 + 확장성)

### 10.2 왜 Python/FastAPI인가?
- AI 라이브러리 풍부 (OpenAI SDK, LangChain)
- 빠른 프로토타이핑
- FastAPI: 비동기 지원, 자동 문서화, 타입 힌트

**대안 비교:**
- Node.js/Express: 프론트엔드와 언어 통일, 하지만 AI 생태계 약함
- Java/Spring: 엔터프라이즈 강점, 하지만 개발 속도 느림

**결정**: Python/FastAPI 선택 (AI 통합 + 개발 속도)

### 10.3 왜 Redis 캐시인가?
- 경로 조회 빈도 높음 (캐시 효과 큼)
- LCA 계산 결과 재사용 가능
- 메모리 기반 빠른 응답

**대안 비교:**
- Memcached: 단순하지만 데이터 구조 제한적
- 인메모리 캐시: 다중 인스턴스 시 불일치

**결정**: Redis 선택 (데이터 구조 + 클러스터)

### 10.4 왜 LCA 알고리즘 2단계인가?
- 초기 트리 규모 작음 → 선형 방식으로 충분
- 트리 커지면 Binary Lifting 필요
- 임계값 기반 자동 전환으로 복잡도 관리

**트레이드오프:**
- 단순성 vs 성능
- 초기 단순함 우선, 필요 시 최적화

## 11. 다음 단계

1. **파일구조 설계서 작성**
   - 디렉토리 구조
   - 파일별 책임 및 크기 제한
   - 명명 규칙

2. **개발자 지시서 작성**
   - 프론트엔드 개발자 지시서
   - 백엔드 개발자 지시서
   - 인터페이스 계약

3. **ADR (Architecture Decision Records) 작성**
   - MongoDB 선택 근거
   - FastAPI 선택 근거
   - 캐시 전략 근거

4. **프로토타입 구현 시작**
   - 핵심 알고리즘 검증
   - 성능 측정 및 튜닝
