# 디자인 패턴 선택 기준 분석 문서

## 1. 목적
본 문서는 AI 고민상담 트리 구조 대화 시스템의 MVP 단계에서 필수 패턴과 선택적 패턴을 구분하는 기준과 근거를 명확히 제시한다. 각 패턴의 적용 필요성과 시점을 객관적으로 분석하여 과설계를 방지하고 개발 효율성을 최적화한다.

## 2. 패턴 분류 기준

### 2.1 필수 패턴 (MVP) 기준
- **핵심 기능 구현에 반드시 필요**: 해당 패턴 없이는 시스템의 기본 동작이 불가능
- **즉시 적용 필요**: 프로토타입 단계에서부터 사용자 경험을 보장하기 위해 필수
- **복잡도 대비 효과**: 패턴 적용 비용보다 얻는 이익이 명확히 크다
- **대안 부재**: 다른 방법으로는 동일한 품질의 결과를 얻기 어렵다

### 2.2 선택적 패턴 (확장 시) 기준
- **성능 최적화**: 현재 규모에서는 필요하지 않지만 확장 시 유용
- **유지보수성 향상**: 장기적 관점에서 도움이 되지만 초기에는 과도할 수 있음
- **대안 존재**: 더 단순한 방법으로도 구현 가능하지만 패턴 적용 시 더 나은 결과
- **점진적 도입 가능**: 시스템이 성숙해진 후 도입해도 문제없음

## 3. 필수 패턴 분석

### 3.1 Flux-lite (상태 관리)

**패턴이란 무엇인가?**
Flux-lite는 애플리케이션의 상태(데이터)를 관리하는 방법입니다. 모든 데이터 변경이 한 방향으로만 흐르도록 강제하여, 상태가 언제, 어디서, 왜 변경되었는지 예측 가능하게 만듭니다. 사용자의 행동(Action) → 데이터 처리(Reducer) → 상태 저장(Store) → 화면 업데이트(View) 순서로만 데이터가 흐릅니다.

**왜 유용한가?**
- **예측 가능성**: 데이터가 항상 같은 경로로만 변경되어 버그를 찾기 쉬움
- **디버깅 용이성**: 문제가 생겼을 때 Action 로그만 보면 원인을 파악할 수 있음
- **일관성 보장**: 여러 화면이 같은 데이터를 참조할 때 동기화 문제가 발생하지 않음
- **테스트 용이성**: 각 단계별로 독립적으로 테스트할 수 있음

**왜 필수인가?**
- **핵심 문제 해결**: 트리 구조에서 노드 클릭 시 여러 컴포넌트(Breadcrumbs, ChatView, TreeView)가 동시에 업데이트되어야 함
- **일관성 보장**: 단방향 데이터 흐름으로 상태 변경 경로를 예측 가능하게 만듦
- **디버깅 용이성**: Action 로그만 추적해도 상태 변화 원인을 파악 가능

**구체적 시나리오**:
```
사용자가 노드 C 클릭 → switchPathAction 발생 → 
LCA 계산 → 경로 재구성 → Store 업데이트 → 
Breadcrumbs/ChatView/TreeView 동시 렌더링
```

**대안과 비교**:
- **이벤트 기반**: 컴포넌트 간 직접 통신으로 복잡도 증가, 디버깅 어려움
- **직접 DOM 조작**: 상태와 뷰 동기화 문제, 유지보수성 저하
- **전역 변수**: 예측 불가능한 상태 변경, 사이드 이펙트 발생

**결론**: 트리 구조 대화 시스템의 핵심인 "클릭 한 번으로 전체 UI 동기화"를 보장하는 유일한 방법

### 3.2 Observer (컴포넌트 통신)

**패턴이란 무엇인가?**
Observer 패턴은 한 객체의 상태가 변경되었을 때, 그 객체에 의존하는 다른 객체들에게 자동으로 알림을 보내는 방법입니다. 우리 시스템에서는 상태가 변경되면 그 상태를 구독하고 있는 모든 컴포넌트들이 자동으로 업데이트됩니다. 마치 뉴스레터 구독처럼, 상태 변경이라는 "뉴스"가 발생하면 구독자들에게 자동으로 전달됩니다.

**왜 유용한가?**
- **자동 동기화**: 상태가 바뀌면 관련된 모든 화면이 자동으로 업데이트됨
- **느슨한 결합**: 컴포넌트들이 서로 직접 연결되지 않아도 됨
- **성능 최적화**: 변경된 부분만 업데이트하여 불필요한 렌더링 방지
- **확장성**: 새로운 컴포넌트를 추가해도 기존 코드 수정 불필요

**왜 필수인가?**
- **느슨한 결합**: 컴포넌트 간 직접 의존성 제거로 재사용성 향상
- **성능 최적화**: 변경된 부분만 렌더링하여 불필요한 리렌더 방지
- **확장성**: 새로운 컴포넌트 추가 시 기존 코드 수정 최소화

**구체적 시나리오**:
```
Store 상태 변경 → 이벤트 버스로 알림 → 
구독한 컴포넌트만 선택적 업데이트
```

**대안과 비교**:
- **직접 참조**: 컴포넌트 간 강결합으로 재사용성 저하
- **폴링**: 성능 저하 및 불필요한 리소스 사용
- **콜백 체인**: 복잡한 의존성으로 유지보수 어려움

**결론**: 다중 컴포넌트 동기화와 성능 최적화를 동시에 달성하는 필수 패턴

### 3.3 Memento (체크포인트)

**패턴이란 무엇인가?**
Memento 패턴은 객체의 현재 상태를 저장해두었다가 나중에 그 상태로 되돌릴 수 있게 하는 방법입니다. 우리 시스템에서는 사용자가 대화를 진행하다가 특정 시점의 상태(경로, 메시지, 설정 등)를 스냅샷으로 저장하고, 필요할 때 그 시점으로 완전히 되돌릴 수 있습니다. 마치 게임에서 세이브 포인트를 만들어두고 언제든 그 지점으로 돌아갈 수 있는 것과 같습니다.

**왜 유용한가?**
- **상태 보존**: 중요한 시점의 상태를 완전히 보존할 수 있음
- **자유로운 실험**: 잘못된 방향으로 진행해도 언제든 되돌릴 수 있음
- **사용자 경험**: 실수에 대한 두려움 없이 자유롭게 탐색 가능
- **디버깅 지원**: 문제가 발생한 시점으로 되돌아가 원인 분석 가능

**왜 필수인가?**
- **핵심 기능**: 체크포인트 저장/복원이 시스템의 주요 가치 제안
- **사용자 경험**: 잘못된 추론 누적 시 즉시 복구 가능
- **데모 효과**: 프로토타입 단계에서 시스템의 핵심 아이디어를 명확히 시연

**구체적 시나리오**:
```
사용자가 잘못된 방향으로 대화 진행 → 
체크포인트 저장 → 계속 대화 → 
문제 발생 시 이전 체크포인트로 복원
```

**대안과 비교**:
- **히스토리 스택**: 단순하지만 메타데이터 부족으로 제한적
- **상태 복사**: 메모리 사용량 증가 및 깊은 복사 비용
- **데이터베이스**: 오버엔지니어링, MVP에 부적합

**결론**: 시스템의 핵심 가치인 "대화 맥락 보존 및 복원"을 구현하는 필수 패턴

## 4. 선택적 패턴 분석

### 4.1 Strategy (LCA 알고리즘)

**왜 선택적인가?**
- **성능 최적화**: 현재 규모(소규모 트리)에서는 선형 LCA로 충분
- **점진적 도입**: 트리 크기 증가 시 Binary Lifting으로 교체 가능
- **복잡도 증가**: 초기에는 단일 알고리즘으로 구현하는 것이 더 단순

**구체적 시나리오**:
```
현재: 선형 LCA (O(h) 시간) → 충분한 성능
확장 시: Binary Lifting (O(log N) 시간) → 대규모 트리 대응
```

**도입 시점**:
- 트리 노드 수가 100개 이상일 때
- 경로 전환 지연이 체감될 때
- 성능 프로파일링 결과 개선 필요성이 확인될 때

**결론**: 현재는 단순한 구현으로 충분하지만, 확장성을 위해 패턴 적용 여지를 남겨둠

### 4.2 Repository (데이터 접근)

**왜 선택적인가?**
- **MVP 단순성**: 초기에는 메모리 저장으로 충분
- **과도한 추상화**: 현재는 단일 저장 방식만 사용
- **점진적 도입**: localStorage 연동 시 도입 고려

**구체적 시나리오**:
```
현재: 직접 메모리 접근 → 단순하고 직관적
확장 시: Repository 패턴 → localStorage, IndexedDB 등 다중 저장소 지원
```

**도입 시점**:
- 데이터 지속화가 필요할 때
- 여러 저장소를 지원해야 할 때
- 테스트를 위해 Mock 저장소가 필요할 때

**결론**: 현재는 불필요하지만 데이터 지속화 요구사항 발생 시 유용한 패턴

## 5. 폴더 구조와 각 폴더의 역할 및 책임

### 5.1 프로젝트 루트 구조

```
myDream/
  docs/                    # 문서 폴더
  web/                     # 웹 애플리케이션 폴더
    public/                # 정적 파일 폴더
    src/                   # 소스 코드 폴더
    tests/                 # 테스트 코드 폴더
```

### 5.2 각 폴더의 상세 역할과 책임

#### 5.2.1 `docs/` 폴더
**프로그래머 관점**: 프로젝트 문서화, 아키텍처 설계서, API 문서, 사용자 가이드 등을 저장하는 폴더

**학생 관점**: 우리 프로젝트의 모든 설명서와 설계도가 들어있는 폴더입니다. 마치 건물을 짓기 전에 그리는 설계도와 같습니다. 이 폴더에는 우리가 만들고자 하는 AI 고민상담 시스템이 어떻게 작동해야 하는지, 어떤 기능들이 필요한지, 어떻게 구현할 것인지에 대한 모든 계획과 설명이 들어있습니다. 개발 과정에서 혼란스러울 때 이 폴더의 문서들을 참고하여 원래 계획대로 진행할 수 있습니다.

**실제 필요성**: 복잡한 시스템을 개발할 때는 여러 사람이 협업하거나, 시간이 지나서 자신이 작성한 코드를 다시 보게 될 때가 있습니다. 이때 문서가 없으면 "이 코드가 왜 이렇게 작성되었지?", "이 기능은 어떻게 사용하는 거지?" 같은 혼란이 생깁니다. 문서는 이런 혼란을 방지하고 프로젝트의 방향성을 유지하는 역할을 합니다.

#### 5.2.2 `web/` 폴더
**프로그래머 관점**: 웹 애플리케이션의 모든 코드와 리소스를 포함하는 루트 폴더

**학생 관점**: 우리가 만들 AI 고민상담 시스템의 실제 웹사이트가 들어있는 폴더입니다. 이 폴더 안에 있는 모든 파일들이 모여서 사용자가 브라우저에서 볼 수 있는 웹사이트가 됩니다. 마치 레스토랑의 주방과 홀을 모두 포함하는 공간과 같습니다. 주방(src)에서 음식을 만들고, 홀(public)에서 손님들이 음식을 받아먹는 것처럼, 이 폴더에서 우리 시스템의 모든 기능이 구현되고 사용자에게 제공됩니다.

**실제 필요성**: 웹 애플리케이션은 여러 종류의 파일들(HTML, CSS, JavaScript, 이미지 등)이 서로 연결되어 작동합니다. 이 모든 파일들을 하나의 폴더에 정리해두면 관리가 쉬워지고, 나중에 서버에 배포할 때도 이 폴더 전체를 올리면 됩니다.

#### 5.2.3 `web/public/` 폴더
**프로그래머 관점**: 정적 파일(HTML, CSS, 이미지, 아이콘 등)을 저장하는 폴더로, 웹 서버에서 직접 서빙되는 파일들이 위치

**학생 관점**: 사용자가 브라우저에서 우리 웹사이트에 접속했을 때 가장 먼저 보게 되는 파일들이 들어있는 폴더입니다. 여기에는 웹사이트의 첫 페이지(index.html), 웹사이트의 모양을 꾸미는 CSS 파일, 로고나 아이콘 같은 이미지 파일들이 들어있습니다. 이 폴더의 파일들은 사용자가 브라우저에서 직접 다운로드받을 수 있는 파일들입니다.

**실제 필요성**: 웹사이트를 만들 때는 사용자가 보는 화면(HTML)과 그 화면을 꾸미는 스타일(CSS), 그리고 웹사이트의 아이덴티티를 나타내는 이미지들이 필요합니다. 이 모든 것들이 public 폴더에 정리되어 있어야 웹서버가 사용자에게 올바르게 전달할 수 있습니다. 만약 이 파일들이 다른 곳에 흩어져 있다면 웹사이트가 제대로 표시되지 않을 것입니다.

#### 5.2.4 `web/src/` 폴더
**프로그래머 관점**: 애플리케이션의 핵심 로직, 컴포넌트, 서비스, 유틸리티 함수 등이 포함된 소스 코드 폴더

**학생 관점**: 우리 AI 고민상담 시스템의 실제 두뇌와 심장이 들어있는 폴더입니다. 여기에는 트리 구조로 대화를 관리하는 알고리즘, 사용자가 클릭했을 때 경로를 바꾸는 로직, 체크포인트를 저장하고 복원하는 기능, 그리고 모든 화면을 구성하는 컴포넌트들이 들어있습니다. 이 폴더의 코드들이 실제로 우리 시스템이 동작하게 만드는 핵심 부분입니다.

**실제 필요성**: 복잡한 웹 애플리케이션은 여러 기능들이 서로 연결되어 작동합니다. 예를 들어, 사용자가 트리의 노드를 클릭하면 → 경로 계산 알고리즘이 실행되고 → 화면이 업데이트되고 → 체크포인트가 저장되는 과정이 모두 src 폴더의 코드들로 구현됩니다. 이 코드들이 없으면 웹사이트는 그냥 정적인 페이지일 뿐, 실제로 동작하는 시스템이 될 수 없습니다.

#### 5.2.5 `web/src/algorithms/` 폴더
**프로그래머 관점**: 순수 함수로 구현된 핵심 알고리즘들(LCA 계산, 경로 재구성 등)을 저장하는 폴더

**학생 관점**: 우리 시스템의 가장 중요한 계산 로직들이 들어있는 폴더입니다. 여기에는 "두 노드 사이의 공통 조상을 찾는 알고리즘", "사용자가 클릭한 노드까지의 경로를 계산하는 알고리즘" 같은 수학적 계산들이 들어있습니다. 이 알고리즘들은 우리 시스템의 핵심인 "트리 구조로 대화를 관리하는 기능"을 실제로 구현하는 부분입니다.

**실제 필요성**: 우리 시스템에서 사용자가 노드를 클릭했을 때 올바른 경로로 전환되려면, 복잡한 수학적 계산이 필요합니다. 예를 들어 A→B→D 경로에서 F를 클릭했을 때 A→B→F로 바뀌는 과정에서 "B가 공통 조상이다"라는 것을 찾아내는 계산이 필요합니다. 이런 계산 로직을 별도 폴더에 정리해두면 나중에 성능을 개선하거나 버그를 수정할 때 쉽게 찾아서 작업할 수 있습니다.

#### 5.2.6 `web/src/components/` 폴더
**프로그래머 관점**: 재사용 가능한 UI 컴포넌트들(TreeView, Breadcrumbs, ChatView 등)을 저장하는 폴더

**학생 관점**: 우리 웹사이트의 화면을 구성하는 각각의 부품들이 들어있는 폴더입니다. 여기에는 "대화를 보여주는 화면", "트리 구조를 보여주는 화면", "현재 경로를 보여주는 화면", "체크포인트를 관리하는 화면" 등이 각각 별도의 파일로 만들어져 있습니다. 마치 레고 블록처럼 이 부품들을 조합해서 전체 화면을 만드는 것입니다.

**실제 필요성**: 웹사이트의 화면은 여러 부분으로 나뉘어 있습니다. 예를 들어 상단에는 현재 경로를 보여주고, 좌측에는 트리 구조를 보여주고, 중앙에는 대화 내용을 보여주는 식입니다. 이런 각각의 부분을 컴포넌트로 만들어두면, 나중에 "대화 화면만 수정하고 싶다"거나 "트리 화면만 개선하고 싶다"고 할 때 해당 파일만 수정하면 됩니다. 또한 같은 컴포넌트를 다른 곳에서도 재사용할 수 있어서 코드 중복을 피할 수 있습니다.

#### 5.2.7 `web/src/state/` 폴더
**프로그래머 관점**: 애플리케이션의 전역 상태 관리(Store, Actions, Reducers)를 담당하는 폴더

**학생 관점**: 우리 시스템의 현재 상태를 기억하고 관리하는 폴더입니다. 여기에는 "현재 어떤 경로가 활성화되어 있는지", "체크포인트가 몇 개 저장되어 있는지", "사용자가 마지막으로 클릭한 노드는 무엇인지" 같은 정보들이 저장되고 관리됩니다. 이 정보들이 없으면 시스템이 현재 어떤 상태인지 모르기 때문에 올바르게 동작할 수 없습니다.

**실제 필요성**: 우리 시스템은 사용자의 행동에 따라 계속 상태가 바뀝니다. 노드를 클릭하면 활성 경로가 바뀌고, 체크포인트를 저장하면 저장 목록이 업데이트되고, 복원을 하면 화면이 이전 상태로 돌아갑니다. 이런 상태 변화를 체계적으로 관리하지 않으면 "화면은 A 경로를 보여주는데 실제 상태는 B 경로" 같은 불일치가 발생할 수 있습니다. 이 폴더의 코드들이 이런 문제를 방지하고 모든 상태를 일관되게 유지하는 역할을 합니다.

#### 5.2.8 `web/src/services/` 폴더
**프로그래머 관점**: 비즈니스 로직과 외부 시스템과의 통신을 담당하는 서비스 레이어 폴더

**학생 관점**: 우리 시스템의 실제 기능들을 실행하는 폴더입니다. 여기에는 "체크포인트를 저장하는 기능", "저장된 체크포인트를 복원하는 기능", "데이터를 브라우저에 저장하는 기능" 등이 들어있습니다. 이 폴더의 코드들이 사용자가 버튼을 클릭했을 때 실제로 그 기능이 동작하게 만드는 부분입니다.

**실제 필요성**: 사용자가 "체크포인트 저장" 버튼을 클릭했을 때, 단순히 버튼만 눌러지는 것이 아니라 실제로 현재 상태를 저장해야 합니다. 이때 필요한 작업들(현재 경로 정보 수집, 타임스탬프 생성, 저장소에 기록 등)을 모두 처리하는 것이 서비스의 역할입니다. 이런 복잡한 작업들을 별도 폴더에 정리해두면 나중에 기능을 수정하거나 개선할 때 쉽게 찾아서 작업할 수 있습니다.

#### 5.2.9 `web/src/models/` 폴더
**프로그래머 관점**: 데이터 모델, 타입 정의, 스키마 검증 등을 담당하는 폴더

**학생 관점**: 우리 시스템에서 사용하는 데이터의 형태와 규칙을 정의하는 폴더입니다. 여기에는 "대화 노드가 어떤 정보를 가져야 하는지", "체크포인트에 어떤 데이터가 들어있어야 하는지" 같은 데이터의 구조와 규칙들이 정의되어 있습니다. 마치 설계도에서 각 부품의 크기와 모양을 정하는 것과 같습니다.

**실제 필요성**: 우리 시스템에서는 여러 종류의 데이터를 다룹니다. 대화 노드, 체크포인트, 사용자 정보 등 각각의 데이터가 어떤 형태여야 하는지 미리 정의해두지 않으면, 나중에 "이 데이터가 올바른 형태인가?", "필요한 정보가 모두 들어있나?" 같은 문제가 발생할 수 있습니다. 이 폴더의 정의들을 통해 데이터의 일관성과 안정성을 보장할 수 있습니다.

#### 5.2.10 `web/src/storage/` 폴더
**프로그래머 관점**: 데이터 저장소 접근을 추상화하는 드라이버들을 저장하는 폴더

**학생 관점**: 우리 시스템의 데이터를 어디에, 어떻게 저장할지를 결정하는 폴더입니다. 여기에는 "브라우저 메모리에 임시로 저장하는 방법", "브라우저의 localStorage에 영구적으로 저장하는 방법" 등이 들어있습니다. 사용자가 체크포인트를 저장하거나 복원할 때 이 폴더의 코드들이 실제로 데이터를 저장하고 불러오는 작업을 담당합니다.

**실제 필요성**: 우리 시스템의 데이터는 여러 곳에 저장될 수 있습니다. 개발 중에는 메모리에 저장하고, 실제 사용할 때는 브라우저에 영구 저장하고, 나중에는 서버 데이터베이스에 저장할 수도 있습니다. 이런 다양한 저장 방식을 지원하려면 각각의 저장 방법을 별도로 구현해야 합니다. 이 폴더에 이런 구현들을 정리해두면 나중에 저장 방식을 바꾸고 싶을 때 쉽게 교체할 수 있습니다.

#### 5.2.11 `web/src/lib/` 폴더
**프로그래머 관점**: 공통 유틸리티 함수, 헬퍼 함수, 도구 함수들을 저장하는 폴더

**학생 관점**: 우리 시스템의 여러 부분에서 공통으로 사용하는 도구들이 들어있는 폴더입니다. 여기에는 "화면 요소를 찾는 함수", "이벤트를 처리하는 함수", "오류를 확인하는 함수", "로그를 출력하는 함수" 등이 들어있습니다. 마치 작업 도구상자처럼 여러 곳에서 필요할 때마다 가져다 쓰는 도구들입니다.

**실제 필요성**: 프로그래밍을 하다 보면 같은 기능을 여러 곳에서 반복해서 사용하는 경우가 많습니다. 예를 들어 "화면에서 특정 요소를 찾는 기능"은 거의 모든 컴포넌트에서 필요합니다. 이런 공통 기능들을 매번 새로 작성하면 코드가 중복되고, 나중에 수정할 때도 여러 곳을 모두 수정해야 합니다. 이 폴더에 공통 기능들을 정리해두면 코드 중복을 피하고 유지보수를 쉽게 할 수 있습니다.

#### 5.2.12 `web/src/styles/` 폴더
**프로그래머 관점**: CSS 스타일시트 파일들을 저장하는 폴더

**학생 관점**: 우리 웹사이트의 모양과 디자인을 결정하는 폴더입니다. 여기에는 "글자 크기와 색깔", "버튼의 모양", "화면의 레이아웃", "애니메이션 효과" 등이 정의되어 있습니다. 이 폴더의 파일들이 우리 웹사이트가 어떻게 보일지를 결정합니다.

**실제 필요성**: 웹사이트는 기능만으로는 사용자가 사용하기 어렵습니다. 사용자가 쉽게 이해하고 사용할 수 있도록 직관적인 디자인이 필요합니다. 예를 들어 "클릭 가능한 버튼은 다른 색으로 표시", "현재 활성화된 경로는 하이라이트", "체크포인트 목록은 구분하기 쉽게 표시" 같은 시각적 가이드가 필요합니다. 이 폴더의 스타일들이 이런 사용자 경험을 제공합니다.

#### 5.2.13 `web/src/mocks/` 폴더
**프로그래머 관점**: 테스트용 샘플 데이터, 목업 데이터를 저장하는 폴더

**학생 관점**: 우리 시스템을 테스트하고 시연하기 위한 예시 데이터들이 들어있는 폴더입니다. 여기에는 "샘플 대화 트리", "예시 체크포인트", "테스트용 메시지" 등이 들어있습니다. 실제 사용자 데이터가 없어도 이 폴더의 데이터로 우리 시스템이 어떻게 동작하는지 확인할 수 있습니다.

**실제 필요성**: 우리 시스템을 개발하고 테스트할 때는 실제 사용자 데이터가 없습니다. 하지만 시스템이 제대로 동작하는지 확인하려면 데이터가 필요합니다. 이 폴더의 샘플 데이터들을 사용해서 "트리 구조가 올바르게 표시되는가?", "경로 전환이 정확히 동작하는가?", "체크포인트 저장/복원이 잘 되는가?" 같은 기능들을 미리 테스트할 수 있습니다.

#### 5.2.14 `web/tests/` 폴더
**프로그래머 관점**: 단위 테스트, 통합 테스트, E2E 테스트 코드를 저장하는 폴더

**학생 관점**: 우리가 작성한 코드가 실제로 잘 동작하는지 자동으로 확인해주는 폴더입니다. 여기에는 "알고리즘이 올바른 결과를 내는지 확인하는 테스트", "컴포넌트가 정확히 렌더링되는지 확인하는 테스트", "전체 시스템이 예상대로 동작하는지 확인하는 테스트" 등이 들어있습니다. 이 테스트들을 실행하면 우리 코드에 문제가 있는지 자동으로 찾아줍니다.

**실제 필요성**: 복잡한 시스템을 개발하다 보면 예상치 못한 버그가 발생할 수 있습니다. 특히 우리 시스템처럼 여러 부분이 서로 연결되어 동작하는 경우, 한 부분을 수정했을 때 다른 부분에 영향을 줄 수 있습니다. 이 폴더의 테스트들을 정기적으로 실행하면 이런 문제들을 미리 발견하고 수정할 수 있습니다. 또한 나중에 기능을 추가하거나 수정할 때도 기존 기능이 여전히 잘 동작하는지 확인할 수 있습니다.

### 4.1 Strategy (LCA 알고리즘)

**왜 선택적인가?**
- **성능 최적화**: 현재 규모(소규모 트리)에서는 선형 LCA로 충분
- **점진적 도입**: 트리 크기 증가 시 Binary Lifting으로 교체 가능
- **복잡도 증가**: 초기에는 단일 알고리즘으로 구현하는 것이 더 단순

**구체적 시나리오**:
```
현재: 선형 LCA (O(h) 시간) → 충분한 성능
확장 시: Binary Lifting (O(log N) 시간) → 대규모 트리 대응
```

**도입 시점**:
- 트리 노드 수가 100개 이상일 때
- 경로 전환 지연이 체감될 때
- 성능 프로파일링 결과 개선 필요성이 확인될 때

**결론**: 현재는 단순한 구현으로 충분하지만, 확장성을 위해 패턴 적용 여지를 남겨둠

### 4.2 Repository (데이터 접근)

**왜 선택적인가?**
- **MVP 단순성**: 초기에는 메모리 저장으로 충분
- **과도한 추상화**: 현재는 단일 저장 방식만 사용
- **점진적 도입**: localStorage 연동 시 도입 고려

**구체적 시나리오**:
```
현재: 직접 메모리 접근 → 단순하고 직관적
확장 시: Repository 패턴 → localStorage, IndexedDB 등 다중 저장소 지원
```

**도입 시점**:
- 데이터 지속화가 필요할 때
- 여러 저장소를 지원해야 할 때
- 테스트를 위해 Mock 저장소가 필요할 때

**결론**: 현재는 불필요하지만 데이터 지속화 요구사항 발생 시 유용한 패턴

## 5. 패턴 적용 우선순위

### 5.1 1단계 (MVP 핵심)
1. **Flux-lite**: 상태 관리 기반 구축
2. **Observer**: 컴포넌트 간 통신 설정
3. **Memento**: 체크포인트 기능 구현

### 5.2 2단계 (기능 완성)
1. **Strategy**: LCA 알고리즘 최적화 (성능 필요 시)
2. **Repository**: 데이터 지속화 (요구사항 발생 시)

### 5.3 3단계 (고도화)
1. **Command**: Undo/Redo 기능 (사용자 요청 시)
2. **Facade**: 서비스 통합 (복잡도 증가 시)
3. **Adapter**: 백엔드 연동 (실제 서비스 구축 시)

## 6. 리스크 관리

### 6.1 과설계 방지
- **점진적 도입**: 필요할 때만 패턴 추가
- **성능 측정**: 패턴 도입 전후 성능 비교
- **복잡도 모니터링**: 코드 복잡도 지표 설정

### 6.2 품질 보장
- **테스트 우선**: 패턴 도입 전 테스트 케이스 작성
- **문서화**: 패턴 적용 이유와 사용법 명시
- **리뷰**: 패턴 적용 필요성 정기 검토

## 7. 결론

필수 패턴 3개(Flux-lite, Observer, Memento)는 시스템의 핵심 기능 구현에 반드시 필요하며, 선택적 패턴 2개(Strategy, Repository)는 확장성과 유지보수성을 위해 점진적으로 도입할 수 있는 패턴이다. 이 분류를 통해 MVP 단계에서 과설계를 방지하면서도 향후 확장성을 확보할 수 있다.

## 8. 다음 액션

1. 필수 패턴 3개를 우선 적용하여 MVP 구현
2. 사용자 피드백을 바탕으로 선택적 패턴 도입 시점 결정
3. 패턴 적용 효과를 정량적으로 측정하여 개선점 파악
