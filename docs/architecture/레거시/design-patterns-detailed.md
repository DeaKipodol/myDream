# 디자인 패턴 상세 설명 문서

## 1. 목적
본 문서는 AI 고민상담 트리 구조 대화 시스템에서 사용하는 각 디자인 패턴이 무엇인지, 왜 유용한지, 어떻게 사용되는지를 상세히 설명한다. 프로그래머와 일반 학생 모두가 이해할 수 있도록 기술적 설명과 실용적 설명을 함께 제공한다.

## 2. 필수 패턴 

### 2.1 Flux-lite (상태 관리)

**어떤 패턴인가?**
Flux-lite는 애플리케이션의 상태(데이터)를 관리하는 방법입니다. 모든 데이터 변경이 한 방향으로만 흐르도록 강제하여, 상태가 언제, 어디서, 왜 변경되었는지 예측 가능하게 만듭니다. 사용자의 행동(Action) → 데이터 처리(Reducer) → 상태 저장(Store) → 화면 업데이트(View) 순서로만 데이터가 흐릅니다.

**왜 유용한가?**
- **예측 가능성**: 데이터가 항상 같은 경로로만 변경되어 버그를 찾기 쉬움
- **디버깅 용이성**: 문제가 생겼을 때 Action 로그만 보면 원인을 파악할 수 있음
- **일관성 보장**: 여러 화면이 같은 데이터를 참조할 때 동기화 문제가 발생하지 않음
- **테스트 용이성**: 각 단계별로 독립적으로 테스트할 수 있음

**우리 시스템에서의 활용**:
```
사용자가 노드 C 클릭 → switchPathAction 발생 → 
LCA 계산 → 경로 재구성 → Store 업데이트 → 
Breadcrumbs/ChatView/TreeView 동시 렌더링
```

**실제 예시**:
- 사용자가 트리의 노드를 클릭하면 "경로 전환" 액션이 발생
- 이 액션은 현재 경로와 목표 노드를 받아서 새로운 경로를 계산
- 계산된 경로가 Store에 저장되면 모든 화면이 자동으로 업데이트
- 이 과정에서 어떤 화면이 업데이트되지 않거나 잘못된 정보를 보여주는 문제가 발생하면, Action 로그를 확인해서 어느 단계에서 문제가 생겼는지 쉽게 파악할 수 있음

### 2.2 Observer (컴포넌트 통신)

**Observer패턴이란 무엇인가?**
Observer 패턴은 한 객체의 상태가 변경되었을 때, 그 객체에 의존하는 다른 객체들에게 자동으로 알림을 보내는 방법입니다. 우리 시스템에서는 상태가 변경되면 그 상태를 구독하고 있는 모든 컴포넌트들이 자동으로 업데이트됩니다. 마치 뉴스레터 구독처럼, 상태 변경이라는 "뉴스"가 발생하면 구독자들에게 자동으로 전달됩니다.

**왜 유용한가?**
- **자동 동기화**: 상태가 바뀌면 관련된 모든 화면이 자동으로 업데이트됨
- **느슨한 결합**: 컴포넌트들이 서로 직접 연결되지 않아도 됨
- **성능 최적화**: 변경된 부분만 업데이트하여 불필요한 렌더링 방지
- **확장성**: 새로운 컴포넌트를 추가해도 기존 코드 수정 불필요

**우리 시스템에서의 활용**:
```
Store 상태 변경 → 이벤트 버스로 알림 → 
구독한 컴포넌트만 선택적 업데이트
```

**실제 예시**:
- 사용자가 노드를 클릭해서 활성 경로가 A→B→D에서 A→C로 바뀜
- 이때 Breadcrumbs 컴포넌트는 "A / C"로 표시를 바꿈
(Breadcrumbs 컴포넌트는 웹사이트에서 현재 위치를 보여주는 네비게이션 요소입니다. 
우리 AI 고민상담 시스템에서는 사용자가 현재 어떤 대화 경로에 있는지를 시각적으로 표시하는 역할을 합니다.)
- ChatView 컴포넌트는 A→C 경로의 대화 내용을 표시
- TreeView 컴포넌트는 C 노드를 하이라이트
- 이 모든 업데이트가 자동으로 일어나며, 각 컴포넌트는 서로를 직접 알 필요가 없음

[참고]
{1. Breadcrumbs 컴포넌트
역할: 현재 대화 경로를 시각적으로 표시
사용자가 현재 어떤 경로에 있는지 보여줌
"A / B / D" 같은 형태로 경로 표시
각 단계를 클릭하면 해당 시점으로 돌아갈 수 있음
2. ChatView 컴포넌트
역할: 실제 대화 내용을 표시하는 메인 화면
현재 활성 경로의 모든 대화 내용을 보여줌
AI와 사용자의 메시지를 채팅 형태로 표시
경로가 바뀌면 해당 경로의 대화 내용으로 업데이트
3. TreeView 컴포넌트
역할: 트리 구조를 시각적으로 표현
전체 대화 트리 구조를 보여줌
현재 활성 노드를 하이라이트로 표시
노드를 클릭하면 해당 경로로 전환
분기점과 하위 노드들을 계층적으로 표시}

### 2.3 Memento (체크포인트)

**패턴이란 무엇인가?**
Memento 패턴은 객체의 현재 상태를 저장해두었다가 나중에 그 상태로 되돌릴 수 있게 하는 방법입니다. 우리 시스템에서는 사용자가 대화를 진행하다가 특정 시점의 상태(경로, 메시지, 설정 등)를 스냅샷으로 저장하고, 필요할 때 그 시점으로 완전히 되돌릴 수 있습니다. 마치 게임에서 세이브 포인트를 만들어두고 언제든 그 지점으로 돌아갈 수 있는 것과 같습니다.

**왜 유용한가?**
- **상태 보존**: 중요한 시점의 상태를 완전히 보존할 수 있음
- **자유로운 실험**: 잘못된 방향으로 진행해도 언제든 되돌릴 수 있음
- **사용자 경험**: 실수에 대한 두려움 없이 자유롭게 탐색 가능
- **디버깅 지원**: 문제가 발생한 시점으로 되돌아가 원인 분석 가능

**우리 시스템에서의 활용**:
```
사용자가 잘못된 방향으로 대화 진행 → 
체크포인트 저장 → 계속 대화 → 
문제 발생 시 이전 체크포인트로 복원
```

**실제 예시**:
- 사용자가 A→B→D 경로로 대화를 진행하다가 "이 방향이 맞나?" 싶어서 체크포인트를 저장
- 계속 대화를 진행하다가 AI가 잘못된 추론을 계속해서 문제가 생김
- 사용자가 저장해둔 체크포인트를 클릭하면 A→B→D 시점으로 완전히 되돌아감
- 이때 화면도, 대화 내용도, 모든 상태가 정확히 그 시점으로 복원됨

**Flux-lite와의 통합 구현**:
Memento 패턴은 Flux-lite 상태 관리 시스템 내부에서 구현됩니다. 체크포인트 저장과 복원이 모두 Action/Reducer 패턴을 통해 처리됩니다.

**동작 순서**:
```
1. 사용자가 분기점에서 체크포인트 저장 버튼 클릭
   ↓
2. 현재 상태 스냅샷 생성 (Memento)
   - activePath: ["A", "B", "D"]
   - 대화 내용, 메타데이터 등 모든 상태
   ↓
3. 스냅샷을 체크포인트 목록에 저장
   ↓
4. 사용자가 계속 대화 진행
   ↓
5. 나중에 체크포인트 복원 버튼 클릭
   ↓
6. 저장된 스냅샷으로 상태 완전 복원
```

**Flux-lite 내부 구현**:
```javascript
// Action 단계
dispatch({ type: 'SAVE_CHECKPOINT', payload: currentState });
dispatch({ type: 'RESTORE_CHECKPOINT', payload: checkpointId });

// Reducer 단계
function reducer(state, action) {
  switch(action.type) {
    case 'SAVE_CHECKPOINT':
      return {
        ...state,
        checkpoints: [...state.checkpoints, createSnapshot(state)]
      };
    
    case 'RESTORE_CHECKPOINT':
      return restoreFromSnapshot(state, action.payload);
  }
}
```

**핵심 특징**:
- **상태 관리 내부 구현**: Memento는 Flux-lite의 Action/Reducer 내부에서 동작
- **불변성 보장**: 스냅샷은 현재 상태의 완전한 복사본
- **자동 동기화**: 복원 시 Observer 패턴으로 모든 뷰가 자동 업데이트
- **완전한 복원**: 단순히 경로만이 아니라 모든 상태가 정확히 복원

## 3. 선택적 패턴 상세 설명

### 3.1 Strategy (LCA 알고리즘)

**패턴이란 무엇인가?**
Strategy 패턴은 같은 작업을 수행하는 여러 가지 방법 중에서 상황에 따라 적절한 방법을 선택할 수 있게 하는 방법입니다. 우리 시스템에서는 트리의 크기에 따라 다른 LCA(최저 공통 조상) 계산 방법을 사용할 수 있습니다. 작은 트리에는 간단한 방법을, 큰 트리에는 빠른 방법을 사용하는 식으로 상황에 맞는 최적의 알고리즘을 선택할 수 있습니다.

**왜 유용한가?**
- **성능 최적화**: 상황에 맞는 최적의 알고리즘 선택 가능
- **유연성**: 새로운 알고리즘을 추가하거나 기존 알고리즘을 교체하기 쉬움
- **코드 재사용**: 같은 인터페이스로 다른 구현을 사용할 수 있음
- **테스트 용이성**: 각 알고리즘을 독립적으로 테스트 가능

**우리 시스템에서의 활용**:
```
현재: 선형 LCA (O(h) 시간) → 충분한 성능
확장 시: Binary Lifting (O(log N) 시간) → 대규모 트리 대응
```

**실제 예시**:
- 현재는 트리가 작아서 간단한 방법으로도 충분히 빠름
- 나중에 트리가 커지면 더 복잡하지만 빠른 방법으로 바꿀 수 있음
- 사용자는 어떤 방법을 쓰는지 모르고, 그냥 노드를 클릭하면 빠르게 경로가 바뀜
- 개발자는 상황에 맞는 최적의 방법을 선택할 수 있음

### 3.2 Repository (데이터 접근)

**패턴이란 무엇인가?**
Repository 패턴은 데이터를 저장하고 불러오는 방법을 추상화하여, 실제 저장소가 무엇인지(메모리, 파일, 데이터베이스 등) 신경 쓰지 않고도 데이터를 다룰 수 있게 하는 방법입니다. 우리 시스템에서는 체크포인트를 저장할 때 메모리에 저장할지, 브라우저 저장소에 저장할지, 나중에 서버에 저장할지를 구분하지 않고 같은 방법으로 사용할 수 있습니다.

**왜 유용한가?**
- **저장소 독립성**: 데이터 저장 방식을 바꿔도 코드 수정 최소화
- **테스트 용이성**: 실제 저장소 대신 가짜 저장소로 테스트 가능
- **유연성**: 개발 중에는 메모리, 운영 중에는 데이터베이스 사용 가능
- **코드 재사용**: 저장소가 바뀌어도 비즈니스 로직은 그대로 사용

**우리 시스템에서의 활용**:
```
현재: 직접 메모리 접근 → 단순하고 직관적
확장 시: Repository 패턴 → localStorage, IndexedDB 등 다중 저장소 지원
```

**실제 예시**:
- 현재는 체크포인트를 브라우저 메모리에 저장
- 나중에 사용자가 브라우저를 닫아도 체크포인트가 남아있도록 localStorage에 저장하고 싶음
- Repository 패턴을 사용하면 저장 방식만 바꾸고 나머지 코드는 그대로 사용 가능
- 테스트할 때는 가짜 저장소를 사용해서 실제 데이터를 건드리지 않고도 테스트 가능

## 4. 패턴 적용 시나리오

### 4.1 시나리오 A: "전환 후 Breadcrumbs가 가끔 틀리게 보인다"
**원인**: 상태를 여러 컴포넌트가 제각각 보관해 레이스가 발생
**패턴 적용**: Flux-lite로 단일 Store를 도입
**결과**: Breadcrumbs/ChatView/TreeView가 같은 상태 소스를 읽어 일관되게 렌더링

### 4.2 시나리오 B: "트리가 커지니 전환이 느려진다"
**원인**: 매 전환마다 깊은 경로 재계산과 전체 리렌더가 발생
**패턴 적용**: Strategy로 LCA 엔진을 선형→Binary Lifting으로 교체 가능하게 함
**결과**: 알고리즘 교체와 부분 갱신으로 체감 지연이 줄어듦

### 4.3 시나리오 C: "잘못된 추론 누적 후 되돌리기가 어렵다"
**원인**: 기존 상태 덮어쓰기로 과거 경로를 복원할 수 없음
**패턴 적용**: Memento로 활성 경로 스냅샷을 남기고 복원 버튼으로 왕복
**결과**: 데모 중 즉시 정상 상태로 복귀 가능, 실수 복구가 빨라짐

## 5. 패턴 선택 가이드

### 5.1 MVP 단계에서 필수인 이유
- **Flux-lite**: 여러 컴포넌트 동기화에 필수
- **Observer**: 성능과 확장성을 동시에 확보
- **Memento**: 시스템의 핵심 가치인 체크포인트 기능 구현

### 5.2 확장 단계에서 고려할 이유
- **Strategy**: 성능 최적화가 필요할 때
- **Repository**: 데이터 지속화가 필요할 때

### 5.3 과설계 방지 원칙
- 현재 문제를 해결하는 최소한의 패턴만 적용
- 필요할 때 점진적으로 추가
- 패턴 적용 효과를 정량적으로 측정

## 6. 결론

각 디자인 패턴은 우리 시스템의 특정 문제를 해결하기 위한 도구입니다. Flux-lite는 상태 관리의 혼란을, Observer는 컴포넌트 간 통신의 복잡성을, Memento는 상태 복원의 어려움을 해결합니다. 이 패턴들을 적절히 활용하면 안정적이고 확장 가능한 시스템을 구축할 수 있습니다.
