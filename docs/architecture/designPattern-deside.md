# 프론트엔드 아키텍처 및 디자인 패턴 통합 문서

## 1. 목적
본 문서는 AI 고민상담 트리 구조 대화 시스템의 프론트엔드 아키텍처 설계와 디자인 패턴 선택 기준을 통합하여 제시한다. 프로그래머와 일반 학생 모두가 이해할 수 있도록 기술적 설명과 실용적 설명을 함께 제공하며, 중복 내용을 제거하고 체계적으로 정리한다.

## 2. 프로젝트 개요

### 2.1 목표
정적 HTML/CSS/JavaScript만으로 다음을 시연하는 것이다:
- TreeView 클릭 한 번으로 활성 경로를 전환
- Breadcrumbs/ChatView가 즉시 동기화
- Checkpoint 생성/복원을 통해 경로 스냅샷을 왕복
- 초기 단계에서는 백엔드를 사용하지 않음
- 데이터는 브라우저 메모리와 선택적으로 localStorage에서 관리

### 2.2 설계 원칙
- **예측 가능성**: 동일 입력에 동일 결과를 보장하는 단방향 데이터 흐름 유지
- **느슨한 결합**: 알고리즘·상태·뷰를 모듈 경계로 분리
- **명확한 책임**: 경로 계산은 알고리즘 계층, 렌더링은 컴포넌트 계층, 스냅샷은 서비스 계층
- **테스트 용이성**: 순수 함수 우선, 부작용은 경계(Service/Storage)로 격리
- **접근성/가시성**: 키보드 네비게이션과 시각적 하이라이트 기본 제공
- **점진적 확장**: 백엔드/AI 연계는 어댑터 계층으로 후속 추가

## 3. 디자인 패턴 분석

### 3.1 필수 패턴 (MVP)

#### 3.1.1 Flux-lite (상태 관리)

**패턴이란 무엇인가?**
Flux-lite는 애플리케이션의 상태(데이터)를 관리하는 방법입니다. 모든 데이터 변경이 한 방향으로만 흐르도록 강제하여, 상태가 언제, 어디서, 왜 변경되었는지 예측 가능하게 만듭니다. 사용자의 행동(Action) → 데이터 처리(Reducer) → 상태 저장(Store) → 화면 업데이트(View) 순서로만 데이터가 흐릅니다.

**왜 유용한가?**
- **예측 가능성**: 데이터가 항상 같은 경로로만 변경되어 버그를 찾기 쉬움
- **디버깅 용이성**: 문제가 생겼을 때 Action 로그만 보면 원인을 파악할 수 있음
- **일관성 보장**: 여러 화면이 같은 데이터를 참조할 때 동기화 문제가 발생하지 않음
- **테스트 용이성**: 각 단계별로 독립적으로 테스트할 수 있음

**우리 시스템에서의 활용**:
```
사용자가 노드 C 클릭 → switchPathAction 발생 → 
LCA 계산 → 경로 재구성 → Store 업데이트 → 
Breadcrumbs/ChatView/TreeView 동시 렌더링
```

**실제 예시**:
- 사용자가 트리의 노드를 클릭하면 "경로 전환" 액션이 발생
- 이 액션은 현재 경로와 목표 노드를 받아서 새로운 경로를 계산
- 계산된 경로가 Store에 저장되면 모든 화면이 자동으로 업데이트
- 이 과정에서 어떤 화면이 업데이트되지 않거나 잘못된 정보를 보여주는 문제가 발생하면, Action 로그를 확인해서 어느 단계에서 문제가 생겼는지 쉽게 파악할 수 있음

#### 3.1.2 Observer (컴포넌트 통신)

**패턴이란 무엇인가?**
Observer 패턴은 한 객체의 상태가 변경되었을 때, 그 객체에 의존하는 다른 객체들에게 자동으로 알림을 보내는 방법입니다. 우리 시스템에서는 상태가 변경되면 그 상태를 구독하고 있는 모든 컴포넌트들이 자동으로 업데이트됩니다. 마치 뉴스레터 구독처럼, 상태 변경이라는 "뉴스"가 발생하면 구독자들에게 자동으로 전달됩니다.

**왜 유용한가?**
- **자동 동기화**: 상태가 바뀌면 관련된 모든 화면이 자동으로 업데이트됨
- **느슨한 결합**: 컴포넌트들이 서로 직접 연결되지 않아도 됨
- **성능 최적화**: 변경된 부분만 업데이트하여 불필요한 렌더링 방지
- **확장성**: 새로운 컴포넌트를 추가해도 기존 코드 수정 불필요

**우리 시스템에서의 활용**:
```
Store 상태 변경 → 이벤트 버스로 알림 → 
구독한 컴포넌트만 선택적 업데이트
```

**실제 예시**:
- 사용자가 노드를 클릭해서 활성 경로가 A→B→D에서 A→C로 바뀜
- 이때 Breadcrumbs 컴포넌트는 "A / C"로 표시를 바꿈
- ChatView 컴포넌트는 A→C 경로의 대화 내용을 표시
- TreeView 컴포넌트는 C 노드를 하이라이트
- 이 모든 업데이트가 자동으로 일어나며, 각 컴포넌트는 서로를 직접 알 필요가 없음

#### 3.1.3 Memento (체크포인트)

**패턴이란 무엇인가?**
Memento 패턴은 객체의 현재 상태를 저장해두었다가 나중에 그 상태로 되돌릴 수 있게 하는 방법입니다. 우리 시스템에서는 사용자가 대화를 진행하다가 특정 시점의 상태(경로, 메시지, 설정 등)를 스냅샷으로 저장하고, 필요할 때 그 시점으로 완전히 되돌릴 수 있습니다. 마치 게임에서 세이브 포인트를 만들어두고 언제든 그 지점으로 돌아갈 수 있는 것과 같습니다.

**왜 유용한가?**
- **상태 보존**: 중요한 시점의 상태를 완전히 보존할 수 있음
- **자유로운 실험**: 잘못된 방향으로 진행해도 언제든 되돌릴 수 있음
- **사용자 경험**: 실수에 대한 두려움 없이 자유롭게 탐색 가능
- **디버깅 지원**: 문제가 발생한 시점으로 되돌아가 원인 분석 가능

**우리 시스템에서의 활용**:
```
사용자가 잘못된 방향으로 대화 진행 → 
체크포인트 저장 → 계속 대화 → 
문제 발생 시 이전 체크포인트로 복원
```

**실제 예시**:
- 사용자가 A→B→D 경로로 대화를 진행하다가 "이 방향이 맞나?" 싶어서 체크포인트를 저장
- 계속 대화를 진행하다가 AI가 잘못된 추론을 계속해서 문제가 생김
- 사용자가 저장해둔 체크포인트를 클릭하면 A→B→D 시점으로 완전히 되돌아감
- 이때 화면도, 대화 내용도, 모든 상태가 정확히 그 시점으로 복원됨

### 3.2 선택적 패턴 (확장 시)

#### 3.2.1 Strategy (LCA 알고리즘)

**패턴이란 무엇인가?**
Strategy 패턴은 같은 작업을 수행하는 여러 가지 방법 중에서 상황에 따라 적절한 방법을 선택할 수 있게 하는 방법입니다. 우리 시스템에서는 트리의 크기에 따라 다른 LCA(최저 공통 조상) 계산 방법을 사용할 수 있습니다. 작은 트리에는 간단한 방법을, 큰 트리에는 빠른 방법을 사용하는 식으로 상황에 맞는 최적의 알고리즘을 선택할 수 있습니다.

**왜 유용한가?**
- **성능 최적화**: 상황에 맞는 최적의 알고리즘 선택 가능
- **유연성**: 새로운 알고리즘을 추가하거나 기존 알고리즘을 교체하기 쉬움
- **코드 재사용**: 같은 인터페이스로 다른 구현을 사용할 수 있음
- **테스트 용이성**: 각 알고리즘을 독립적으로 테스트 가능

**왜 선택적인가?**
- **성능 최적화**: 현재 규모(소규모 트리)에서는 선형 LCA로 충분
- **점진적 도입**: 트리 크기 증가 시 Binary Lifting으로 교체 가능
- **복잡도 증가**: 초기에는 단일 알고리즘으로 구현하는 것이 더 단순

**우리 시스템에서의 활용**:
```
현재: 선형 LCA (O(h) 시간) → 충분한 성능
확장 시: Binary Lifting (O(log N) 시간) → 대규모 트리 대응
```

#### 3.2.2 Repository (데이터 접근)

**패턴이란 무엇인가?**
Repository 패턴은 데이터를 저장하고 불러오는 방법을 추상화하여, 실제 저장소가 무엇인지(메모리, 파일, 데이터베이스 등) 신경 쓰지 않고도 데이터를 다룰 수 있게 하는 방법입니다. 우리 시스템에서는 체크포인트를 저장할 때 메모리에 저장할지, 브라우저 저장소에 저장할지, 나중에 서버에 저장할지를 구분하지 않고 같은 방법으로 사용할 수 있습니다.

**왜 유용한가?**
- **저장소 독립성**: 데이터 저장 방식을 바꿔도 코드 수정 최소화
- **테스트 용이성**: 실제 저장소 대신 가짜 저장소로 테스트 가능
- **유연성**: 개발 중에는 메모리, 운영 중에는 데이터베이스 사용 가능
- **코드 재사용**: 저장소가 바뀌어도 비즈니스 로직은 그대로 사용

**왜 선택적인가?**
- **MVP 단순성**: 초기에는 메모리 저장으로 충분
- **과도한 추상화**: 현재는 단일 저장 방식만 사용
- **점진적 도입**: localStorage 연동 시 도입 고려

**우리 시스템에서의 활용**:
```
현재: 직접 메모리 접근 → 단순하고 직관적
확장 시: Repository 패턴 → localStorage, IndexedDB 등 다중 저장소 지원
```

### 3.3 패턴 적용 시나리오

#### 3.3.1 시나리오 A: "전환 후 Breadcrumbs가 가끔 틀리게 보인다"
- **원인**: 상태를 여러 컴포넌트가 제각각 보관해 레이스가 발생
- **패턴 적용**: Flux-lite로 단일 Store를 도입
- **결과**: Breadcrumbs/ChatView/TreeView가 같은 상태 소스를 읽어 일관되게 렌더링

#### 3.3.2 시나리오 B: "트리가 커지니 전환이 느려진다"
- **원인**: 매 전환마다 깊은 경로 재계산과 전체 리렌더가 발생
- **패턴 적용**: Strategy로 LCA 엔진을 선형→Binary Lifting으로 교체 가능하게 함
- **결과**: 알고리즘 교체와 부분 갱신으로 체감 지연이 줄어듦

#### 3.3.3 시나리오 C: "잘못된 추론 누적 후 되돌리기가 어렵다"
- **원인**: 기존 상태 덮어쓰기로 과거 경로를 복원할 수 없음
- **패턴 적용**: Memento로 활성 경로 스냅샷을 남기고 복원 버튼으로 왕복
- **결과**: 데모 중 즉시 정상 상태로 복귀 가능, 실수 복구가 빨라짐

## 4. 폴더 구조와 각 폴더의 역할

### 4.1 프로젝트 루트 구조

```
myDream/
  docs/                    # 문서 폴더
  web/                     # 웹 애플리케이션 폴더
    public/                # 정적 파일 폴더
    src/                   # 소스 코드 폴더
    tests/                 # 테스트 코드 폴더
```

### 4.2 각 폴더의 상세 역할과 책임

#### 4.2.1 `docs/` 폴더
**프로그래머 관점**: 프로젝트 문서화, 아키텍처 설계서, API 문서, 사용자 가이드 등을 저장하는 폴더

**학생 관점**: 우리 프로젝트의 모든 설명서와 설계도가 들어있는 폴더입니다. 이 폴더에는 우리가 만들고자 하는 AI 고민상담 시스템이 어떻게 작동해야 하는지, 어떤 기능들이 필요한지, 어떻게 구현할 것인지에 대한 모든 계획과 설명이 들어있습니다. 개발 과정에서 혼란스러울 때 이 폴더의 문서들을 참고하여 원래 계획대로 진행할 수 있습니다.

**실제 필요성**: 복잡한 시스템을 개발할 때는 여러 사람이 협업하거나, 시간이 지나서 자신이 작성한 코드를 다시 보게 될 때가 있습니다. 이때 문서가 없으면 "이 코드가 왜 이렇게 작성되었지?", "이 기능은 어떻게 사용하는 거지?" 같은 혼란이 생깁니다. 문서는 이런 혼란을 방지하고 프로젝트의 방향성을 유지하는 역할을 합니다.

#### 4.2.2 `web/` 폴더
**프로그래머 관점**: 웹 애플리케이션의 모든 코드와 리소스를 포함하는 루트 폴더

**학생 관점**: 우리가 만들 AI 고민상담 시스템의 실제 웹사이트가 들어있는 폴더입니다. 이 폴더 안에 있는 모든 파일들이 모여서 사용자가 브라우저에서 볼 수 있는 웹사이트가 됩니다. 이 폴더에서 우리 시스템의 모든 기능이 구현되고 사용자에게 제공됩니다.

**실제 필요성**: 웹 애플리케이션은 여러 종류의 파일들(HTML, CSS, JavaScript, 이미지 등)이 서로 연결되어 작동합니다. 이 모든 파일들을 하나의 폴더에 정리해두면 관리가 쉬워지고, 나중에 서버에 배포할 때도 이 폴더 전체를 올리면 됩니다.

#### 4.2.3 `web/public/` 폴더
**프로그래머 관점**: 정적 파일(HTML, CSS, 이미지, 아이콘 등)을 저장하는 폴더로, 웹 서버에서 직접 서빙되는 파일들이 위치

**학생 관점**: 사용자가 브라우저에서 우리 웹사이트에 접속했을 때 가장 먼저 보게 되는 파일들이 들어있는 폴더입니다. 여기에는 웹사이트의 첫 페이지(index.html), 웹사이트의 모양을 꾸미는 CSS 파일, 로고나 아이콘 같은 이미지 파일들이 들어있습니다. 이 폴더의 파일들은 사용자가 브라우저에서 직접 다운로드받을 수 있는 파일들입니다.

**실제 필요성**: 웹사이트를 만들 때는 사용자가 보는 화면(HTML)과 그 화면을 꾸미는 스타일(CSS), 그리고 웹사이트의 아이덴티티를 나타내는 이미지들이 필요합니다. 이 모든 것들이 public 폴더에 정리되어 있어야 웹서버가 사용자에게 올바르게 전달할 수 있습니다. 만약 이 파일들이 다른 곳에 흩어져 있다면 웹사이트가 제대로 표시되지 않을 것입니다.

#### 4.2.4 `web/src/` 폴더
**프로그래머 관점**: 애플리케이션의 핵심 로직, 컴포넌트, 서비스, 유틸리티 함수 등이 포함된 소스 코드 폴더

**학생 관점**: 우리 AI 고민상담 시스템의 실제 두뇌와 심장이 들어있는 폴더입니다. 여기에는 트리 구조로 대화를 관리하는 알고리즘, 사용자가 클릭했을 때 경로를 바꾸는 로직, 체크포인트를 저장하고 복원하는 기능, 그리고 모든 화면을 구성하는 컴포넌트들이 들어있습니다. 이 폴더의 코드들이 실제로 우리 시스템이 동작하게 만드는 핵심 부분입니다.

**실제 필요성**: 복잡한 웹 애플리케이션은 여러 기능들이 서로 연결되어 작동합니다. 예를 들어, 사용자가 트리의 노드를 클릭하면 → 경로 계산 알고리즘이 실행되고 → 화면이 업데이트되고 → 체크포인트가 저장되는 과정이 모두 src 폴더의 코드들로 구현됩니다. 이 코드들이 없으면 웹사이트는 그냥 정적인 페이지일 뿐, 실제로 동작하는 시스템이 될 수 없습니다.

#### 4.2.5 `web/src/algorithms/` 폴더
**프로그래머 관점**: 순수 함수로 구현된 핵심 알고리즘들(LCA 계산, 경로 재구성 등)을 저장하는 폴더

**학생 관점**: 우리 시스템의 가장 중요한 계산 로직들이 들어있는 폴더입니다. 여기에는 "두 노드 사이의 공통 조상을 찾는 알고리즘", "사용자가 클릭한 노드까지의 경로를 계산하는 알고리즘" 같은 수학적 계산들이 들어있습니다. 이 알고리즘들은 우리 시스템의 핵심인 "트리 구조로 대화를 관리하는 기능"을 실제로 구현하는 부분입니다.

**실제 필요성**: 우리 시스템에서 사용자가 노드를 클릭했을 때 올바른 경로로 전환되려면, 복잡한 수학적 계산이 필요합니다. 예를 들어 A→B→D 경로에서 F를 클릭했을 때 A→B→F로 바뀌는 과정에서 "B가 공통 조상이다"라는 것을 찾아내는 계산이 필요합니다. 이런 계산 로직을 별도 폴더에 정리해두면 나중에 성능을 개선하거나 버그를 수정할 때 쉽게 찾아서 작업할 수 있습니다.

#### 4.2.6 `web/src/components/` 폴더
**프로그래머 관점**: 재사용 가능한 UI 컴포넌트들(TreeView, Breadcrumbs, ChatView 등)을 저장하는 폴더

**학생 관점**: 우리 웹사이트의 화면을 구성하는 각각의 부품들이 들어있는 폴더입니다. 여기에는 "대화를 보여주는 화면", "트리 구조를 보여주는 화면", "현재 경로를 보여주는 화면", "체크포인트를 관리하는 화면" 등이 각각 별도의 파일로 만들어져 있습니다. 마치 레고 블록처럼 이 부품들을 조합해서 전체 화면을 만드는 것입니다.

**실제 필요성**: 웹사이트의 화면은 여러 부분으로 나뉘어 있습니다. 예를 들어 상단에는 현재 경로를 보여주고, 좌측에는 트리 구조를 보여주고, 중앙에는 대화 내용을 보여주는 식입니다. 이런 각각의 부분을 컴포넌트로 만들어두면, 나중에 "대화 화면만 수정하고 싶다"거나 "트리 화면만 개선하고 싶다"고 할 때 해당 파일만 수정하면 됩니다. 또한 같은 컴포넌트를 다른 곳에서도 재사용할 수 있어서 코드 중복을 피할 수 있습니다.

#### 4.2.7 `web/src/state/` 폴더
**프로그래머 관점**: 애플리케이션의 전역 상태 관리(Store, Actions, Reducers)를 담당하는 폴더

**학생 관점**: 우리 시스템의 현재 상태를 기억하고 관리하는 폴더입니다. 여기에는 "현재 어떤 경로가 활성화되어 있는지", "체크포인트가 몇 개 저장되어 있는지", "사용자가 마지막으로 클릭한 노드는 무엇인지" 같은 정보들이 저장되고 관리됩니다. 이 정보들이 없으면 시스템이 현재 어떤 상태인지 모르기 때문에 올바르게 동작할 수 없습니다.

**실제 필요성**: 우리 시스템은 사용자의 행동에 따라 계속 상태가 바뀝니다. 노드를 클릭하면 활성 경로가 바뀌고, 체크포인트를 저장하면 저장 목록이 업데이트되고, 복원을 하면 화면이 이전 상태로 돌아갑니다. 이런 상태 변화를 체계적으로 관리하지 않으면 "화면은 A 경로를 보여주는데 실제 상태는 B 경로" 같은 불일치가 발생할 수 있습니다. 이 폴더의 코드들이 이런 문제를 방지하고 모든 상태를 일관되게 유지하는 역할을 합니다.

#### 4.2.8 `web/src/services/` 폴더
**프로그래머 관점**: 비즈니스 로직과 외부 시스템과의 통신을 담당하는 서비스 레이어 폴더

**학생 관점**: 우리 시스템의 실제 기능들을 실행하는 폴더입니다. 여기에는 "체크포인트를 저장하는 기능", "저장된 체크포인트를 복원하는 기능", "데이터를 브라우저에 저장하는 기능" 등이 들어있습니다. 이 폴더의 코드들이 사용자가 버튼을 클릭했을 때 실제로 그 기능이 동작하게 만드는 부분입니다.

**실제 필요성**: 사용자가 "체크포인트 저장" 버튼을 클릭했을 때, 단순히 버튼만 눌러지는 것이 아니라 실제로 현재 상태를 저장해야 합니다. 이때 필요한 작업들(현재 경로 정보 수집, 타임스탬프 생성, 저장소에 기록 등)을 모두 처리하는 것이 서비스의 역할입니다. 이런 복잡한 작업들을 별도 폴더에 정리해두면 나중에 기능을 수정하거나 개선할 때 쉽게 찾아서 작업할 수 있습니다.

#### 4.2.9 `web/src/models/` 폴더
**프로그래머 관점**: 데이터 모델, 타입 정의, 스키마 검증 등을 담당하는 폴더

**학생 관점**: 우리 시스템에서 사용하는 데이터의 형태와 규칙을 정의하는 폴더입니다. 여기에는 "대화 노드가 어떤 정보를 가져야 하는지", "체크포인트에 어떤 데이터가 들어있어야 하는지" 같은 데이터의 구조와 규칙들이 정의되어 있습니다. 마치 설계도에서 각 부품의 크기와 모양을 정하는 것과 같습니다.

**실제 필요성**: 우리 시스템에서는 여러 종류의 데이터를 다룹니다. 대화 노드, 체크포인트, 사용자 정보 등 각각의 데이터가 어떤 형태여야 하는지 미리 정의해두지 않으면, 나중에 "이 데이터가 올바른 형태인가?", "필요한 정보가 모두 들어있나?" 같은 문제가 발생할 수 있습니다. 이 폴더의 정의들을 통해 데이터의 일관성과 안정성을 보장할 수 있습니다.

#### 4.2.10 `web/src/storage/` 폴더
**프로그래머 관점**: 데이터 저장소 접근을 추상화하는 드라이버들을 저장하는 폴더

**학생 관점**: 우리 시스템의 데이터를 어디에, 어떻게 저장할지를 결정하는 폴더입니다. 여기에는 "브라우저 메모리에 임시로 저장하는 방법", "브라우저의 localStorage에 영구적으로 저장하는 방법" 등이 들어있습니다. 사용자가 체크포인트를 저장하거나 복원할 때 이 폴더의 코드들이 실제로 데이터를 저장하고 불러오는 작업을 담당합니다.

**실제 필요성**: 우리 시스템의 데이터는 여러 곳에 저장될 수 있습니다. 개발 중에는 메모리에 저장하고, 실제 사용할 때는 브라우저에 영구 저장하고, 나중에는 서버 데이터베이스에 저장할 수도 있습니다. 이런 다양한 저장 방식을 지원하려면 각각의 저장 방법을 별도로 구현해야 합니다. 이 폴더에 이런 구현들을 정리해두면 나중에 저장 방식을 바꾸고 싶을 때 쉽게 교체할 수 있습니다.

#### 4.2.11 `web/src/lib/` 폴더
**프로그래머 관점**: 공통 유틸리티 함수, 헬퍼 함수, 도구 함수들을 저장하는 폴더

**학생 관점**: 우리 시스템의 여러 부분에서 공통으로 사용하는 도구들이 들어있는 폴더입니다. 여기에는 "화면 요소를 찾는 함수", "이벤트를 처리하는 함수", "오류를 확인하는 함수", "로그를 출력하는 함수" 등이 들어있습니다. 마치 작업 도구상자처럼 여러 곳에서 필요할 때마다 가져다 쓰는 도구들입니다.

**실제 필요성**: 프로그래밍을 하다 보면 같은 기능을 여러 곳에서 반복해서 사용하는 경우가 많습니다. 예를 들어 "화면에서 특정 요소를 찾는 기능"은 거의 모든 컴포넌트에서 필요합니다. 이런 공통 기능들을 매번 새로 작성하면 코드가 중복되고, 나중에 수정할 때도 여러 곳을 모두 수정해야 합니다. 이 폴더에 공통 기능들을 정리해두면 코드 중복을 피하고 유지보수를 쉽게 할 수 있습니다.

#### 4.2.12 `web/src/styles/` 폴더
**프로그래머 관점**: CSS 스타일시트 파일들을 저장하는 폴더

**학생 관점**: 우리 웹사이트의 모양과 디자인을 결정하는 폴더입니다. 여기에는 "글자 크기와 색깔", "버튼의 모양", "화면의 레이아웃", "애니메이션 효과" 등이 정의되어 있습니다. 이 폴더의 파일들이 우리 웹사이트가 어떻게 보일지를 결정합니다.

**실제 필요성**: 웹사이트는 기능만으로는 사용자가 사용하기 어렵습니다. 사용자가 쉽게 이해하고 사용할 수 있도록 직관적인 디자인이 필요합니다. 예를 들어 "클릭 가능한 버튼은 다른 색으로 표시", "현재 활성화된 경로는 하이라이트", "체크포인트 목록은 구분하기 쉽게 표시" 같은 시각적 가이드가 필요합니다. 이 폴더의 스타일들이 이런 사용자 경험을 제공합니다.

#### 4.2.13 `web/src/mocks/` 폴더
**프로그래머 관점**: 테스트용 샘플 데이터, 목업 데이터를 저장하는 폴더

**학생 관점**: 우리 시스템을 테스트하고 시연하기 위한 예시 데이터들이 들어있는 폴더입니다. 여기에는 "샘플 대화 트리", "예시 체크포인트", "테스트용 메시지" 등이 들어있습니다. 실제 사용자 데이터가 없어도 이 폴더의 데이터로 우리 시스템이 어떻게 동작하는지 확인할 수 있습니다.

**실제 필요성**: 우리 시스템을 개발하고 테스트할 때는 실제 사용자 데이터가 없습니다. 하지만 시스템이 제대로 동작하는지 확인하려면 데이터가 필요합니다. 이 폴더의 샘플 데이터들을 사용해서 "트리 구조가 올바르게 표시되는가?", "경로 전환이 정확히 동작하는가?", "체크포인트 저장/복원이 잘 되는가?" 같은 기능들을 미리 테스트할 수 있습니다.

#### 4.2.14 `web/tests/` 폴더
**프로그래머 관점**: 단위 테스트, 통합 테스트, E2E 테스트 코드를 저장하는 폴더

**학생 관점**: 우리가 작성한 코드가 실제로 잘 동작하는지 자동으로 확인해주는 폴더입니다. 여기에는 "알고리즘이 올바른 결과를 내는지 확인하는 테스트", "컴포넌트가 정확히 렌더링되는지 확인하는 테스트", "전체 시스템이 예상대로 동작하는지 확인하는 테스트" 등이 들어있습니다. 이 테스트들을 실행하면 우리 코드에 문제가 있는지 자동으로 찾아줍니다.

**실제 필요성**: 복잡한 시스템을 개발하다 보면 예상치 못한 버그가 발생할 수 있습니다. 특히 우리 시스템처럼 여러 부분이 서로 연결되어 동작하는 경우, 한 부분을 수정했을 때 다른 부분에 영향을 줄 수 있습니다. 이 폴더의 테스트들을 정기적으로 실행하면 이런 문제들을 미리 발견하고 수정할 수 있습니다. 또한 나중에 기능을 추가하거나 수정할 때도 기존 기능이 여전히 잘 동작하는지 확인할 수 있습니다.

## 5. 모듈 경계와 책임

- **algorithms**: lca 계산, 경로 재구성(prefix/suffix) 순수 함수 집합
- **state**: 전역 Store, Action/Reducer, 구독/알림
- **services**: checkpoint/shelves/storage 등 부작용 처리 레이어
- **components**: TreeView/Breadcrumbs/ChatView/ControlPanel 등 UI 조각
- **views**: App/Layout 등 화면 조합과 라우팅(필요 시) 관리
- **models**: Node/Checkpoint 타입·스키마·가드
- **storage**: in-memory, localStorage 드라이버
- **lib**: 공통 유틸(dom, event, assert, logger)
- **styles**: 토큰/베이스/컴포넌트/유틸 클래스
- **mocks**: 샘플 트리 데이터(A~I) 및 픽스처

## 6. 상태/이벤트/렌더 파이프라인

- **입력**: 사용자가 TreeView에서 노드를 클릭한다
- **처리**: Action(dispatch) → LCA/경로 재구성(algorithms) → 서비스 후처리(보존 표시/체크포인트 선택) → Store 상태 갱신
- **출력**: 구독된 렌더러가 Breadcrumbs/ChatView/TreeView를 부분 갱신
- **성능**: 변경된 suffix 구간만 하이라이트, 최소 재렌더 정책

## 7. 네이밍 규칙

- **파일/모듈**: 케밥케이스, 클래스/컴포넌트는 파스칼케이스(TreeView.js)
- **함수**: 동사-목적어, 순수 함수는 명사형 지양(getPathToRoot, computeLca)
- **상태 키**: activePathIds, activeLeafId, checkpoints, shelves, uiFlags
- **주석**: JSDoc 간단 계약(입력/출력/부작용/오류)

## 8. 단계적 구현 순서

### 8.1 1단계 (기초)
algorithms(lca/path) → state(store) → components(Breadcrumbs/ChatView) → TreeView(클릭) → 전환 렌더

### 8.2 2단계 (스냅샷)
services(checkpoint/storage) → Checkpoint UI → 복원/왕복 검증

### 8.3 3단계 (가시성/접근성)
하이라이트·애니메이션·키보드 네비게이션·ARIA 라벨

### 8.4 4단계 (옵션)
shelves 표시, localStorage 지속화, 간단 테스트

## 9. 패턴 선택 가이드

### 9.1 MVP 단계에서 필수인 이유
- **Flux-lite**: 여러 컴포넌트 동기화에 필수
- **Observer**: 성능과 확장성을 동시에 확보
- **Memento**: 시스템의 핵심 가치인 체크포인트 기능 구현

### 9.2 확장 단계에서 고려할 이유
- **Strategy**: 성능 최적화가 필요할 때
- **Repository**: 데이터 지속화가 필요할 때

### 9.3 과설계 방지 원칙
- 현재 문제를 해결하는 최소한의 패턴만 적용
- 필요할 때 점진적으로 추가
- 패턴 적용 효과를 정량적으로 측정

## 10. 리스크 관리

### 10.1 과설계 방지
- **점진적 도입**: 필요할 때만 패턴 추가
- **성능 측정**: 패턴 도입 전후 성능 비교
- **복잡도 모니터링**: 코드 복잡도 지표 설정

### 10.2 품질 보장
- **테스트 우선**: 패턴 도입 전 테스트 케이스 작성
- **문서화**: 패턴 적용 이유와 사용법 명시
- **리뷰**: 패턴 적용 필요성 정기 검토

## 11. 결론

각 디자인 패턴은 우리 시스템의 특정 문제를 해결하기 위한 도구입니다. Flux-lite는 상태 관리의 혼란을, Observer는 컴포넌트 간 통신의 복잡성을, Memento는 상태 복원의 어려움을 해결합니다. 이 패턴들을 적절히 활용하면 안정적이고 확장 가능한 시스템을 구축할 수 있습니다.

## 12. 다음 액션

- **현재 단계**: 문서 확정 및 동의
- **다음 단계**: "실행" 지시 수신 후 web/ 이하 골격과 최소 목업(HTML/CSS/JS) 생성
